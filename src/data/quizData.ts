import { QuizQuestion } from './types';

export const quizQuestions: QuizQuestion[] = [
  // M1 - Intro
  { id: 'q1', lessonId: 'm1-intro', question: 'O que é a JVM?', options: ['Um editor de código Java', 'A máquina virtual que executa bytecode Java', 'O compilador Java', 'Uma biblioteca do Java'], correct: 1, explanation: 'JVM (Java Virtual Machine) é a máquina virtual que interpreta e executa o bytecode (.class) gerado pelo compilador javac.' },
  { id: 'q2', lessonId: 'm1-intro', question: 'Qual é o ponto de entrada de um programa Java?', options: ['A primeira linha do arquivo', 'O método start()', 'O método main(String[] args)', 'O construtor da classe'], correct: 2, explanation: 'O método public static void main(String[] args) é o ponto de entrada de todo programa Java.' },
  { id: 'q3', lessonId: 'm1-intro', question: 'Qual comando compila um arquivo Java?', options: ['java MeuPrograma.java', 'javac MeuPrograma.java', 'compile MeuPrograma.java', 'run MeuPrograma.java'], correct: 1, explanation: 'O comando javac (Java Compiler) compila o código-fonte .java em bytecode .class.' },
  { id: 'q4', lessonId: 'm1-intro', question: 'System.out.println() faz o quê?', options: ['Lê entrada do usuário', 'Imprime e pula linha', 'Imprime sem pular linha', 'Cria uma variável'], correct: 1, explanation: 'println() imprime o texto e pula uma linha. print() imprime sem pular linha.' },
  { id: 'q5', lessonId: 'm1-intro', question: 'Qual a diferença entre JDK e JRE?', options: ['São a mesma coisa', 'JDK é para desenvolver, JRE é para executar', 'JRE é para desenvolver, JDK é para executar', 'JDK é mais antigo que JRE'], correct: 1, explanation: 'JDK (Development Kit) contém ferramentas de desenvolvimento + JRE. JRE (Runtime Environment) contém apenas o necessário para executar.' },
  { id: 'q6', lessonId: 'm1-intro', question: 'Qual a saída deste código?\nSystem.out.print("A");\nSystem.out.println("B");\nSystem.out.print("C");', code: 'System.out.print("A");\nSystem.out.println("B");\nSystem.out.print("C");', options: ['A B C', 'AB\\nC', 'ABC', 'A\\nB\\nC'], correct: 1, explanation: 'print("A") imprime A sem pular. println("B") imprime B e pula linha. print("C") imprime C. Resultado: AB(nova linha)C.' },

  // M1 - Variables
  { id: 'q10', lessonId: 'm1-variables', question: 'Qual tipo primitivo é mais usado para números inteiros?', options: ['byte', 'short', 'int', 'long'], correct: 2, explanation: 'int é o tipo padrão para inteiros em Java, com alcance de aproximadamente -2 bilhões a 2 bilhões.' },
  { id: 'q11', lessonId: 'm1-variables', question: 'Como comparar o conteúdo de duas Strings?', options: ['str1 == str2', 'str1.equals(str2)', 'str1.compare(str2)', 'str1 === str2'], correct: 1, explanation: '== compara referências (endereço na memória). .equals() compara o conteúdo real da String.' },
  { id: 'q12', lessonId: 'm1-variables', question: 'O que acontece em: int x = (int) 9.7;', options: ['x = 10 (arredonda)', 'x = 9 (trunca)', 'Erro de compilação', 'x = 9.7'], correct: 1, explanation: 'Casting de double para int TRUNCA (corta a parte decimal), não arredonda. 9.7 vira 9.' },
  { id: 'q13', lessonId: 'm1-variables', question: 'Qual declaração está CORRETA?', options: ['float x = 3.14;', 'float x = 3.14f;', 'float x = 3.14d;', 'Float x = 3.14;'], correct: 1, explanation: 'Literais decimais são double por padrão. Para float, adicione f: 3.14f.' },
  { id: 'q14', lessonId: 'm1-variables', question: 'String é um tipo primitivo?', options: ['Sim', 'Não, é um tipo de referência (objeto)', 'Depende do contexto', 'Sim, mas só a partir do Java 11'], correct: 1, explanation: 'String é uma classe (tipo de referência), não um tipo primitivo. Os 8 primitivos são: byte, short, int, long, float, double, char, boolean.' },
  { id: 'q15', lessonId: 'm1-variables', question: 'Qual é o valor padrão de uma variável boolean?', options: ['true', 'false', 'null', '0'], correct: 1, explanation: 'Variáveis boolean de instância (atributos) têm valor padrão false. Variáveis locais precisam ser inicializadas.' },

  // M1 - Arrays
  { id: 'q20', lessonId: 'm1-arrays', question: 'Qual o índice do primeiro elemento de um array?', options: ['1', '0', '-1', 'Depende do tamanho'], correct: 1, explanation: 'Arrays em Java (e na maioria das linguagens) começam no índice 0.' },
  { id: 'q21', lessonId: 'm1-arrays', question: 'O que acontece ao acessar array[array.length]?', options: ['Retorna o último elemento', 'Retorna null', 'ArrayIndexOutOfBoundsException', 'Retorna 0'], correct: 2, explanation: 'O último índice válido é array.length - 1. Acessar array.length causa ArrayIndexOutOfBoundsException.' },
  { id: 'q22', lessonId: 'm1-arrays', question: 'Qual a diferença entre .length e .length()?', options: ['São iguais', '.length para arrays, .length() para Strings', '.length() para arrays, .length para Strings', 'Nenhuma, ambos funcionam para tudo'], correct: 1, explanation: 'Arrays usam .length (propriedade, sem parênteses). Strings usam .length() (método, com parênteses).' },
  { id: 'q23', lessonId: 'm1-arrays', question: 'int[] nums = {5, 10, 15}; Qual o valor de nums[1]?', options: ['5', '10', '15', 'Erro'], correct: 1, explanation: 'Índice 0 = 5, índice 1 = 10, índice 2 = 15.' },
  { id: 'q24', lessonId: 'm1-arrays', question: 'Qual loop é preferível quando NÃO precisamos do índice?', options: ['for clássico', 'while', 'for-each (for : )', 'do-while'], correct: 2, explanation: 'O for-each (for (int x : array)) é mais limpo e menos propenso a erros quando não precisamos do índice.' },
  { id: 'q24b', lessonId: 'm1-arrays', question: 'Qual método de java.util.Arrays ordena um array?', options: ['Arrays.order()', 'Arrays.sort()', 'Arrays.arrange()', 'array.sort()'], correct: 1, explanation: 'Arrays.sort(array) ordena o array em ordem crescente. É um método estático da classe java.util.Arrays.' },

  // M1 - Loops
  { id: 'q30', lessonId: 'm1-loops', question: 'Qual loop garante pelo menos uma execução?', options: ['for', 'while', 'do-while', 'for-each'], correct: 2, explanation: 'O do-while executa o bloco primeiro e depois verifica a condição. Garante pelo menos uma execução.' },
  { id: 'q31', lessonId: 'm1-loops', question: 'O que o break faz dentro de um loop?', options: ['Pula para a próxima iteração', 'Encerra o loop imediatamente', 'Pausa a execução por 1 segundo', 'Reinicia o loop'], correct: 1, explanation: 'break encerra o loop imediatamente. continue pula para a próxima iteração.' },
  { id: 'q32', lessonId: 'm1-loops', question: 'Qual a saída?\nfor (int i = 0; i < 3; i++) {\n  System.out.print(i + " ");\n}', code: 'for (int i = 0; i < 3; i++) {\n  System.out.print(i + " ");\n}', options: ['1 2 3', '0 1 2', '0 1 2 3', '1 2'], correct: 1, explanation: 'i começa em 0 e vai até 2 (i < 3). Imprime: 0 1 2.' },
  { id: 'q34', lessonId: 'm1-loops', question: 'O que o continue faz dentro de um loop?', options: ['Encerra o loop', 'Pula para a próxima iteração', 'Pausa a execução', 'Reinicia o loop do zero'], correct: 1, explanation: 'continue pula o restante do corpo do loop e vai para a próxima iteração. Diferente do break, que encerra o loop.' },
  { id: 'q35', lessonId: 'm1-loops', question: 'Qual loop é mais adequado quando NÃO sabemos quantas vezes vamos repetir?', options: ['for', 'while', 'for-each', 'Nenhum'], correct: 1, explanation: 'while é ideal quando a repetição depende de uma condição e não sabemos previamente quantas iterações serão. for é melhor quando sabemos o número de iterações.' },
  { id: 'q36', lessonId: 'm1-loops', question: 'Qual a saída?\nfor (int i = 0; i < 5; i++) {\n  if (i == 3) break;\n  System.out.print(i + " ");\n}', code: 'for (int i = 0; i < 5; i++) {\n  if (i == 3) break;\n  System.out.print(i + " ");\n}', options: ['0 1 2 3 4', '0 1 2', '0 1 2 4', '3'], correct: 1, explanation: 'Quando i chega a 3, o break encerra o loop imediatamente. Os valores impressos são: 0 1 2.' },

  // M1 - if/else
  { id: 'q40', lessonId: 'm1-ifelse', question: 'Qual operador ternário está correto?', options: ['x > 5 : "sim" ? "não"', 'x > 5 ? "sim" : "não"', 'x > 5 ?? "sim" :: "não"', '(x > 5) -> "sim" | "não"'], correct: 1, explanation: 'A sintaxe do ternário é: condição ? valorTrue : valorFalse.' },
  { id: 'q41', lessonId: 'm1-ifelse', question: 'if (x = 5) — o que está errado?', options: ['Nada, está correto', 'Usa = (atribuição) ao invés de == (comparação)', 'Faltam chaves', 'x não foi declarado'], correct: 1, explanation: '= é atribuição (define valor). == é comparação (verifica igualdade). No if, use ==.' },
  { id: 'q42', lessonId: 'm1-ifelse', question: 'Para que serve o else if?', options: ['Substituir o switch', 'Testar outra condição quando a anterior for false', 'Criar um loop', 'Encerrar o programa'], correct: 1, explanation: 'else if permite encadear múltiplas condições. Se o primeiro if for false, testa o else if, e assim por diante.' },
  { id: 'q43', lessonId: 'm1-ifelse', question: 'Qual a saída?\nint x = 10;\nif (x > 5) {\n  System.out.print("A");\n} else if (x > 8) {\n  System.out.print("B");\n}', code: 'int x = 10;\nif (x > 5) {\n  System.out.print("A");\n} else if (x > 8) {\n  System.out.print("B");\n}', options: ['AB', 'A', 'B', 'Nenhuma saída'], correct: 1, explanation: 'O primeiro if (x > 5) é true, então imprime "A". O else if NÃO é avaliado porque o if anterior já foi true. Em cadeia if/else, apenas UM bloco executa.' },
  { id: 'q44', lessonId: 'm1-ifelse', question: 'O que acontece se NÃO usar chaves {} no if com duas linhas de código?', options: ['Funciona normalmente', 'Apenas a primeira linha pertence ao if; a segunda sempre executa', 'Erro de compilação', 'As duas linhas pertencem ao if'], correct: 1, explanation: 'Sem chaves, apenas a PRIMEIRA instrução faz parte do if. As demais executam sempre, independente da condição. Sempre use chaves para evitar bugs.' },
  { id: 'q44b', lessonId: 'm1-ifelse', question: 'Qual expressão correta do operador ternário para: se nota >= 7, "Aprovado", senão "Reprovado"?', options: ['nota >= 7 : "Aprovado" ? "Reprovado"', 'nota >= 7 ? "Aprovado" : "Reprovado"', 'nota >= 7 && "Aprovado" || "Reprovado"', 'if nota >= 7 then "Aprovado" else "Reprovado"'], correct: 1, explanation: 'Sintaxe do ternário: condição ? valorTrue : valorFalse. Neste caso: nota >= 7 ? "Aprovado" : "Reprovado".' },

  // M1 - Switch
  { id: 'q45', lessonId: 'm1-switch', question: 'O que acontece se esquecer o break num case?', options: ['Erro de compilação', 'Fall-through: executa os cases seguintes', 'O switch para', 'Volta ao primeiro case'], correct: 1, explanation: 'Sem break, a execução "cai" para o próximo case (fall-through). Geralmente é um bug.' },
  { id: 'q46', lessonId: 'm1-switch', question: 'O switch pode ser usado com String?', options: ['Não, apenas com int', 'Sim, a partir do Java 7', 'Apenas com enum', 'Não em Java'], correct: 1, explanation: 'A partir do Java 7, switch aceita String na variável.' },
  { id: 'q47', lessonId: 'm1-switch', question: 'Para que serve o default no switch?', options: ['É obrigatório', 'É executado quando nenhum case corresponde', 'Reinicia o switch', 'Define o valor padrão da variável'], correct: 1, explanation: 'default é como o "else": executado quando nenhum case corresponde ao valor.' },
  { id: 'q48', lessonId: 'm1-switch', question: 'Quais tipos o switch NÃO aceita em Java?', options: ['String e int', 'double, float e boolean', 'char e byte', 'int e enum'], correct: 1, explanation: 'switch aceita: byte, short, int, char, String (Java 7+) e enum. NÃO aceita: double, float, long e boolean.' },
  { id: 'q49', lessonId: 'm1-switch', question: 'Qual a saída?\nint x = 2;\nswitch(x) {\n  case 1: System.out.print("A");\n  case 2: System.out.print("B");\n  case 3: System.out.print("C");\n}', code: 'int x = 2;\nswitch(x) {\n  case 1: System.out.print("A");\n  case 2: System.out.print("B");\n  case 3: System.out.print("C");\n}', options: ['B', 'BC', 'ABC', 'C'], correct: 1, explanation: 'Sem break, ocorre fall-through: após o case 2 executar, o case 3 também executa. Resultado: BC.' },
  { id: 'q49b', lessonId: 'm1-switch', question: 'Quando o switch é mais indicado que if/else?', options: ['Sempre', 'Quando temos muitas comparações de igualdade com uma mesma variável', 'Quando usamos operadores como > e <', 'Nunca, são iguais'], correct: 1, explanation: 'switch é ideal para comparar UMA variável com vários valores fixos. Para condições com intervalos (>, <, >=), use if/else.' },

  // M1 - Matrices
  { id: 'q25', lessonId: 'm1-matrices', question: 'O que é uma matriz em Java?', options: ['Um array de uma dimensão', 'Um array de arrays (2D)', 'Um tipo primitivo', 'Uma classe especial'], correct: 1, explanation: 'Matriz é um array bidimensional: int[][] — cada elemento é um array.' },
  { id: 'q26', lessonId: 'm1-matrices', question: 'Como acessar o elemento da linha 1, coluna 2?', options: ['matriz(1, 2)', 'matriz[1][2]', 'matriz.get(1, 2)', 'matriz[2][1]'], correct: 1, explanation: 'Acesso é por colchetes: matriz[linha][coluna]. Índices começam em 0.' },
  { id: 'q27', lessonId: 'm1-matrices', question: 'matriz.length retorna o quê?', options: ['Número total de elementos', 'Número de colunas', 'Número de linhas', 'O tamanho em memória'], correct: 2, explanation: 'Em uma matriz 2D, matriz.length é o número de linhas (quantos arrays ela contém).' },
  { id: 'q27b', lessonId: 'm1-matrices', question: 'Como obter o número de colunas da linha i?', options: ['matriz.length', 'matriz[i].length', 'matriz.width', 'matriz[i].size()'], correct: 1, explanation: 'matriz.length = número de linhas. matriz[i].length = número de colunas da linha i. Em Java, cada linha pode ter tamanho diferente (jagged array).' },
  { id: 'q27c', lessonId: 'm1-matrices', question: 'Para percorrer toda uma matriz 2D, precisamos de:', options: ['Um loop simples', 'Dois loops aninhados (linhas e colunas)', 'Três loops', 'Um for-each apenas'], correct: 1, explanation: 'O loop externo percorre as linhas e o loop interno percorre as colunas de cada linha. Ex: for(i) { for(j) { matriz[i][j] } }' },
  { id: 'q27d', lessonId: 'm1-matrices', question: 'int[][] m = new int[3][4]; quantos elementos essa matriz armazena?', options: ['3', '4', '7', '12'], correct: 3, explanation: '3 linhas × 4 colunas = 12 elementos no total.' },

  // M1 - Functions
  { id: 'q28', lessonId: 'm1-functions', question: 'O que significa void em um método?', options: ['O método retorna 0', 'O método não retorna valor', 'O método é vazio', 'O método é opcional'], correct: 1, explanation: 'void indica que o método não retorna nenhum valor.' },
  { id: 'q29', lessonId: 'm1-functions', question: 'O que é sobrecarga de método?', options: ['Método com muitos parâmetros', 'Vários métodos com o mesmo nome e parâmetros diferentes', 'Método que chama a si mesmo', 'Método que retorna sobrecarga'], correct: 1, explanation: 'Sobrecarga (overloading): mesmo nome, lista de parâmetros diferente na mesma classe.' },
  { id: 'q33', lessonId: 'm1-functions', question: 'Onde variáveis locais existem?', options: ['Em todo o programa', 'Apenas dentro do método onde foram declaradas', 'Em todas as classes', 'Em arquivos .java'], correct: 1, explanation: 'Variáveis declaradas dentro de um método são locais a esse método e deixam de existir quando ele termina.' },
  { id: 'q33b', lessonId: 'm1-functions', question: 'Qual a diferença entre parâmetro e argumento?', options: ['São a mesma coisa', 'Parâmetro é a variável na declaração; argumento é o valor passado na chamada', 'Argumento é na declaração; parâmetro na chamada', 'Parâmetro é para void, argumento é para retorno'], correct: 1, explanation: 'Parâmetro: variável na assinatura do método (ex: int x). Argumento: valor real passado ao chamar (ex: somar(5, 3)).' },
  { id: 'q33c', lessonId: 'm1-functions', question: 'O que acontece quando um método executa return?', options: ['O programa encerra', 'O método para imediatamente e devolve o valor ao chamador', 'O loop mais próximo para', 'Nada especial'], correct: 1, explanation: 'return encerra o método e devolve o valor especificado. Código após o return no mesmo bloco não é executado.' },
  { id: 'q33d', lessonId: 'm1-functions', question: 'Posso ter dois métodos chamados "calcular" na mesma classe?', options: ['Não, dá erro', 'Sim, se tiverem parâmetros diferentes (sobrecarga)', 'Só se um for void', 'Só se forem static'], correct: 1, explanation: 'Sobrecarga (overloading) permite métodos com o mesmo nome desde que a lista de parâmetros seja diferente (tipo, quantidade ou ordem).' },

  // M1 - Operators
  { id: 'q50', lessonId: 'm1-operators', question: 'Qual o resultado de 10 / 3 em Java (inteiros)?', options: ['3.33', '3', '4', '3.0'], correct: 1, explanation: 'Divisão entre inteiros resulta em inteiro. 10 / 3 = 3 (truncado). Para decimal: 10.0 / 3 = 3.33...' },
  { id: 'q51', lessonId: 'm1-operators', question: 'O que o operador % retorna?', options: ['A divisão', 'O quociente', 'O resto da divisão', 'A porcentagem'], correct: 2, explanation: '% (módulo) retorna o RESTO da divisão inteira. Ex: 10 % 3 = 1.' },
  { id: 'q52', lessonId: 'm1-operators', question: 'Qual a diferença entre ++i e i++?', options: ['São iguais', '++i incrementa antes de usar; i++ usa e depois incrementa', '++i é mais rápido', 'i++ é para loops, ++i é para if'], correct: 1, explanation: '++i (pré-incremento) incrementa primeiro e depois retorna o valor. i++ (pós-incremento) retorna o valor atual e depois incrementa. Ex: int i = 5; System.out.print(i++); imprime 5, e depois i vira 6.' },
  { id: 'q53', lessonId: 'm1-operators', question: 'O que o operador && faz se a primeira condição for false?', options: ['Avalia a segunda condição mesmo assim', 'Não avalia a segunda condição (curto-circuito)', 'Dá erro', 'Retorna null'], correct: 1, explanation: '&& (AND lógico) usa curto-circuito: se a primeira condição for false, já sabe que o resultado é false e NÃO avalia a segunda. Útil para evitar NullPointerException.' },
  { id: 'q54', lessonId: 'm1-operators', question: 'Qual o resultado de: 2 + 3 * 4?', options: ['20', '14', '12', '24'], correct: 1, explanation: 'Multiplicação (*) tem precedência sobre adição (+). Primeiro: 3 * 4 = 12, depois 2 + 12 = 14. Para mudar a ordem: (2 + 3) * 4 = 20.' },
  { id: 'q55', lessonId: 'm1-operators', question: 'Qual operador verifica se dois valores são DIFERENTES?', options: ['<>', '!=', '!==', 'not'], correct: 1, explanation: '!= é o operador "diferente de" em Java. Retorna true se os valores forem diferentes.' },

  // M2 - I/O (Scanner)
  { id: 'qm2-1', lessonId: 'm2-io', question: 'Por que chamar nextLine() após nextInt() ou nextDouble()?', options: ['Para fechar o Scanner', 'Para limpar o buffer e evitar pular a próxima leitura', 'É obrigatório em Java', 'Para ler a próxima linha'], correct: 1, explanation: 'O Enter digitado após o número fica no buffer. Sem nextLine(), o próximo nextLine() consome essa linha vazia.' },
  { id: 'qm2-2', lessonId: 'm2-io', question: 'Qual método do Scanner lê uma linha inteira?', options: ['next()', 'nextLine()', 'nextString()', 'readLine()'], correct: 1, explanation: 'nextLine() lê até a quebra de linha. next() lê até o próximo espaço ou fim de linha.' },
  { id: 'qm2-3', lessonId: 'm2-io', question: 'Para ler dados do teclado, o Scanner é criado com:', options: ['new Scanner(File)', 'new Scanner(System.in)', 'new Scanner(Keyboard)', 'Scanner.create()'], correct: 1, explanation: 'System.in é o fluxo de entrada padrão (teclado).' },

  // M2 - Strings
  { id: 'qm2-4', lessonId: 'm2-strings', question: 'Strings em Java são imutáveis. Isso significa:', options: ['Não podem ser usadas', 'Métodos como trim() retornam uma nova String, a original não muda', 'Só podem ser criadas uma vez', 'Não podem ser comparadas'], correct: 1, explanation: 'Imutável = o conteúdo do objeto não muda. Operações retornam novos objetos.' },
  { id: 'qm2-5', lessonId: 'm2-strings', question: 'Para concatenar muitas strings em um loop, o mais eficiente é:', options: ['Usar + em cada iteração', 'StringBuilder', 'String.concat() em cada iteração', 'Arrays de char'], correct: 1, explanation: 'StringBuilder evita criar dezenas de objetos String intermediários.' },
  { id: 'qm2-6', lessonId: 'm2-strings', question: '"a,b,c".split(",") retorna:', options: ['Uma String', 'Um array String[] com três elementos', 'Um ArrayList', 'Um char[]'], correct: 1, explanation: 'split() divide a String e retorna um array de Strings.' },

  // M2 - Debug
  { id: 'qm2-7', lessonId: 'm2-debug', question: 'No stack trace, a primeira linha "at arquivo.java:10" indica:', options: ['A linha 10 do arquivo onde o erro ocorreu', 'O número de erros', 'A versão do Java', 'O nome do projeto'], correct: 0, explanation: 'Indica o arquivo e o número da linha onde a exceção foi lançada.' },
  { id: 'qm2-8', lessonId: 'm2-debug', question: 'NullPointerException geralmente significa:', options: ['Array vazio', 'Chamou método ou acessou campo em uma referência null', 'Divisão por zero', 'Arquivo não encontrado'], correct: 1, explanation: 'Alguma variável está null e você tentou usá-la (método ou campo).' },
  { id: 'qm2-9', lessonId: 'm2-debug', question: 'ArrayIndexOutOfBoundsException indica:', options: ['O array é null', 'Você acessou um índice fora do tamanho do array', 'O array está vazio', 'Tipo errado no array'], correct: 1, explanation: 'Ex.: acessar índice 5 em um array de tamanho 3.' },

  // M2 - Collections
  { id: 'qm2-10', lessonId: 'm2-collections', question: 'Qual a principal vantagem do ArrayList em relação ao array?', options: ['É mais rápido', 'Tamanho dinâmico: pode adicionar e remover elementos', 'Usa menos memória', 'Só aceita objetos'], correct: 1, explanation: 'Array tem tamanho fixo; ArrayList cresce e diminui conforme necessário.' },
  { id: 'qm2-11', lessonId: 'm2-collections', question: 'Por que não podemos usar ArrayList<int>?', options: ['Podemos, é válido', 'Generics em Java não aceitam tipos primitivos; use ArrayList<Integer>', 'int não existe em Java', 'ArrayList só aceita String'], correct: 1, explanation: 'Generics trabalham apenas com tipos de referência (objetos).' },
  { id: 'qm2-12', lessonId: 'm2-collections', question: 'Para obter o número de elementos em um ArrayList lista:', options: ['lista.length', 'lista.length()', 'lista.size()', 'lista.count()'], correct: 2, explanation: 'ArrayList usa size(); arrays usam length.' },

  // M2 - Packages
  { id: 'qm2-13', lessonId: 'm2-packages', question: 'A declaração package no arquivo Java deve estar:', options: ['No final do arquivo', 'Na primeira linha útil do arquivo (após comentários)', 'Dentro da classe', 'No import'], correct: 1, explanation: 'package é a primeira instrução do arquivo (comentários podem vir antes).' },
  { id: 'qm2-14', lessonId: 'm2-packages', question: 'Para usar a classe ArrayList de outro pacote, usamos:', options: ['package java.util.ArrayList', 'import java.util.ArrayList;', 'include java.util.ArrayList', 'require java.util.ArrayList'], correct: 1, explanation: 'import traz a classe para o escopo do arquivo.' },
  { id: 'qm2-15', lessonId: 'm2-packages', question: 'A convenção de nomes para pacotes em Java é:', options: ['PascalCase', 'geralmente minúsculo, ex: com.empresa.projeto', 'UPPER_SNAKE', 'camelCase'], correct: 1, explanation: 'Pacotes são em minúsculas; múltiplas palavras em um nível podem usar algo como com.empresa.meuProjeto.' },

  // M3 - POO (O que é POO e Por Que Existe)
  { id: 'q60', lessonId: 'm3-whatispoo', question: 'Quais são os 4 pilares da POO?', options: ['Variáveis, Funções, Arrays, Loops', 'Classe, Objeto, Método, Atributo', 'Encapsulamento, Herança, Polimorfismo, Abstração', 'public, private, protected, static'], correct: 2, explanation: 'Os 4 pilares da POO são: Encapsulamento (proteger dados), Herança (reaproveitar código), Polimorfismo (mesmo método, comportamento diferente) e Abstração (definir o que, não como).' },
  { id: 'q61', lessonId: 'm3-whatispoo', question: 'Por que usamos "private" nos atributos de uma classe?', options: ['Para o código compilar mais rápido', 'Para impedir acesso direto e forçar o uso de métodos com validação', 'Porque o Java exige que tudo seja private', 'Para poder usar static'], correct: 1, explanation: 'Atributos private só podem ser acessados dentro da própria classe. Para alterar, precisa usar métodos (como depositar, vender), que fazem validação antes. Isso é Encapsulamento.' },
  { id: 'q62', lessonId: 'm3-whatispoo', question: 'No código procedural, o que tende a acontecer quando o sistema cresce?', options: ['Fica mais rápido', 'Dados e regras ficam espalhados, difícil de manter', 'O compilador otimiza sozinho', 'Só funciona em Java'], correct: 1, explanation: 'Sem POO, funções e dados soltos tornam o código frágil e difícil de manter quando o sistema cresce. Variáveis podem ser alteradas sem validação de qualquer lugar.' },
  { id: 'q62b', lessonId: 'm3-whatispoo', question: 'Após sc.nextInt(), o que acontece se chamar sc.nextLine() logo em seguida?', options: ['Lê o próximo texto normalmente', 'Lê uma string vazia (o Enter que sobrou no buffer)', 'Dá erro de compilação', 'O programa trava'], correct: 1, explanation: 'nextInt() lê o número mas deixa o Enter no buffer. O nextLine() seguinte consome esse Enter e retorna "". Solução: colocar um sc.nextLine() extra entre eles para limpar o buffer.' },
  { id: 'q62c', lessonId: 'm3-whatispoo', question: 'Qual a diferença entre Classe e Objeto?', options: ['São a mesma coisa', 'Classe é o molde/receita, Objeto é a instância criada com new', 'Objeto é o molde, Classe é a instância', 'Classe só existe em Java'], correct: 1, explanation: 'A Classe define a estrutura (atributos e métodos). O Objeto é a instância real criada na memória com new. Uma classe pode gerar infinitos objetos independentes.' },

  // M3 - Classes e Objetos
  { id: 'q65', lessonId: 'm3-classes', question: 'Qual a relação entre Classe e Objeto?', options: ['São a mesma coisa', 'Classe é o molde, Objeto é a instância criada com new', 'Objeto é o molde, Classe é a instância', 'Não há relação'], correct: 1, explanation: 'A Classe é o molde/template que define atributos e métodos. O Objeto é a instância real criada na memória com new.' },
  { id: 'q66', lessonId: 'm3-classes', question: 'O que acontece quando fazemos Carro b = a; (sem new)?', options: ['Cria uma cópia independente do objeto', 'b aponta para o MESMO objeto que a na memória', 'Dá erro de compilação', 'Cria dois objetos iguais'], correct: 1, explanation: 'Sem new, a variável b recebe a referência (endereço) do mesmo objeto. Alterar b.cor também altera a.cor porque ambas apontam para o mesmo local na memória.' },
  { id: 'q67', lessonId: 'm3-classes', question: 'Cada objeto de uma mesma classe tem seus próprios atributos?', options: ['Não, todos compartilham', 'Sim, cada instância tem sua própria cópia dos atributos', 'Só se forem static', 'Só em C++'], correct: 1, explanation: 'Atributos de instância (não static) são próprios de cada objeto. Alterar meuCarro.cor não afeta outroCarro.cor.' },
  { id: 'q67b', lessonId: 'm3-classes', question: 'Quantas classes public podem existir em um único arquivo .java?', options: ['Quantas quiser', 'No máximo uma', 'Exatamente duas', 'Nenhuma'], correct: 1, explanation: 'Cada arquivo .java pode ter apenas UMA classe public, e o nome do arquivo deve ser igual ao nome dessa classe.' },
  { id: 'q67c', lessonId: 'm3-classes', question: 'Para modelar classes a partir de um enunciado, substantivos viram ___ e verbos viram ___.', options: ['métodos / atributos', 'classes ou atributos / métodos', 'variáveis / funções', 'imports / exports'], correct: 1, explanation: 'Substantivos do problema (Aluno, nota, nome) viram classes ou atributos. Verbos (calcular, exibir, emprestar) viram métodos.' },

  // M3 - Atributos e Métodos
  { id: 'q68', lessonId: 'm3-attributes', question: 'Qual o valor padrão de um atributo do tipo String ao criar um objeto com new?', options: ['""  (string vazia)', 'null', '0', 'undefined'], correct: 1, explanation: 'Atributos de tipo String (e qualquer objeto) são inicializados como null. Tipos primitivos numéricos (int, double) começam com 0, e boolean com false.' },
  { id: 'q69', lessonId: 'm3-attributes', question: 'Métodos que alteram o estado devem:', options: ['Sempre ser public', 'Validar parâmetros e condições antes de alterar', 'Ser static', 'Retornar void obrigatoriamente'], correct: 1, explanation: 'Boa prática: sempre validar (ex.: qtd > 0 && qtd <= estoque) antes de modificar atributos, para evitar estados inválidos.' },
  { id: 'q69b', lessonId: 'm3-attributes', question: 'Qual a diferença entre um método void e um método com retorno?', options: ['Não há diferença', 'void não retorna valor; métodos com retorno devolvem um resultado ao chamador', 'void é mais rápido', 'Métodos com retorno não podem ter parâmetros'], correct: 1, explanation: 'void indica que o método executa ações mas não devolve resultado. Métodos com retorno (int, double, boolean, String) devolvem um valor que o chamador pode guardar em uma variável.' },
  { id: 'q69f', lessonId: 'm3-attributes', question: 'O que acontece se você não guardar o retorno de um método em uma variável?', options: ['Dá erro de compilação', 'O resultado é perdido/ignorado', 'O valor é salvo automaticamente', 'O programa trava'], correct: 1, explanation: 'Se você chama calc.somar(10, 20) sem guardar em uma variável, o resultado 30 é calculado mas descartado. Precisa fazer: double r = calc.somar(10, 20);' },

  // M3 - Construtores
  { id: 'q69c', lessonId: 'm3-constructors', question: 'Quando o construtor é chamado?', options: ['Ao declarar a classe', 'Automaticamente no momento do new', 'No final do programa', 'Quando chamamos super()'], correct: 1, explanation: 'O construtor roda automaticamente quando você executa new NomeClasse(...). Ele inicializa o objeto com os valores passados.' },
  { id: 'q69d', lessonId: 'm3-constructors', question: 'O que acontece se definir um construtor com parâmetros mas não definir um construtor vazio?', options: ['Nada muda', 'new Classe() sem argumentos dá erro de compilação', 'O Java cria um construtor vazio automaticamente', 'O programa compila mas trava em runtime'], correct: 1, explanation: 'Ao definir qualquer construtor com parâmetros, o construtor padrão (sem parâmetros) desaparece. Para usar new Classe(), precisa definir o construtor vazio explicitamente.' },
  { id: 'q69e', lessonId: 'm3-constructors', question: 'Para que serve this() dentro de um construtor?', options: ['Criar novo objeto', 'Chamar outro construtor da MESMA classe', 'Chamar o construtor da classe pai', 'Retornar o objeto atual'], correct: 1, explanation: 'this() chama outro construtor da mesma classe, permitindo reutilizar lógica sem duplicar código. Deve ser a primeira linha do construtor.' },
  { id: 'q69g', lessonId: 'm3-constructors', question: 'O que acontece se escrever "nome = nome" (sem this) no construtor?', options: ['Funciona normalmente', 'O parâmetro é atribuído a si mesmo e o atributo da classe fica null', 'Dá erro de compilação', 'O programa trava'], correct: 1, explanation: 'Sem this, "nome" se refere ao parâmetro nos dois lados. O parâmetro é atribuído a ele mesmo e o atributo da classe continua com o valor padrão (null para String, 0 para int).' },

  // M3 - Static
  { id: 'q73', lessonId: 'm3-static', question: 'Membros static pertencem a:', options: ['Cada objeto', 'À classe (compartilhados por todos)', 'Só ao main', 'Nenhum'], correct: 1, explanation: 'static = da classe, compartilhado por todas as instâncias.' },
  { id: 'q74', lessonId: 'm3-static', question: 'Um método static pode acessar um atributo de instância (não static)?', options: ['Sim, sempre', 'Não, não existe this em contexto static', 'Só se for public', 'Só em C++'], correct: 1, explanation: 'Em método static não há referência a um objeto (this); logo não dá para acessar atributos de instância.' },
  { id: 'q75', lessonId: 'm3-static', question: 'Como chamar um método static?', options: ['objeto.metodo()', 'NomeClasse.metodo()', 'super.metodo()', 'this.metodo()'], correct: 1, explanation: 'Métodos static são chamados pela classe: Funcionario.getTotal().' },

  // M3 - this
  { id: 'q76', lessonId: 'm3-this', question: 'O que é this dentro de um método de instância?', options: ['A classe', 'Referência ao objeto atual que está executando o método', 'O método pai', 'O pacote'], correct: 1, explanation: 'this é a referência ao próprio objeto que recebeu a chamada do método.' },
  { id: 'q77', lessonId: 'm3-this', question: 'Para que serve retornar this em um setter?', options: ['Para compilar', 'Para permitir method chaining (encadear chamadas)', 'Para criar cópia', 'Nada'], correct: 1, explanation: 'return this permite objeto.setA(1).setB(2).' },
  { id: 'q78', lessonId: 'm3-this', question: 'Podemos usar this em um método static?', options: ['Sim', 'Não, não existe objeto atual em static', 'Só no main', 'Só em interface'], correct: 1, explanation: 'Em static não há "objeto atual"; this não existe.' },

  // M3 - Inheritance (already has q80, q81)

  // M3 - Encapsulation
  { id: 'q70', lessonId: 'm3-encapsulation', question: 'Por que usar private nos atributos?', options: ['Para o código compilar mais rápido', 'Para proteger dados de alterações inválidas', 'Porque é obrigatório em Java', 'Para economizar memória'], correct: 1, explanation: 'private impede acesso direto. O atributo só pode ser lido/alterado por métodos da própria classe, que fazem validação.' },
  { id: 'q71', lessonId: 'm3-encapsulation', question: 'Todo atributo private precisa de getter E setter?', options: ['Sim, sempre', 'Não, depende se o atributo precisa ser lido ou alterado de fora', 'Sim, é obrigatório', 'Não, nunca use setters'], correct: 1, explanation: 'Crie getters/setters apenas quando necessário. CPF pode ter só getter (somente leitura). Saldo é melhor controlado por depositar/sacar. Dados internos podem não ter nenhum dos dois.' },
  { id: 'q72', lessonId: 'm3-encapsulation', question: 'O que é "encapsulamento falso"?', options: ['Usar private sem getters', 'Criar setters que apenas fazem this.x = x sem validação', 'Não usar construtores', 'Usar public em todos os atributos'], correct: 1, explanation: 'Encapsulamento falso é ter atributos private mas setters sem validação (tipo setSaldo(s) { this.saldo = s; }). Aceita qualquer valor — mesma coisa que public, com mais código.' },
  { id: 'q72b', lessonId: 'm3-encapsulation', question: 'Qual a convenção para getter de atributos boolean?', options: ['getAtivo()', 'isAtivo()', 'hasAtivo()', 'checkAtivo()'], correct: 1, explanation: 'Para atributos boolean, a convenção Java é usar "is" em vez de "get": isAtivo(), isVazio(), isPago(). Para outros tipos, usa-se getXxx().' },

  // M3 - Inheritance
  { id: 'q80', lessonId: 'm3-inheritance', question: 'Qual palavra-chave indica herança?', options: ['implements', 'extends', 'inherits', 'super'], correct: 1, explanation: 'extends indica que uma classe herda de outra. implements é para interfaces.' },
  { id: 'q81', lessonId: 'm3-inheritance', question: 'Quando NÃO usar herança?', options: ['Quando a relação é "é um"', 'Quando a relação é "tem um"', 'Quando quer reaproveitar código sempre', 'Nunca, sempre use'], correct: 1, explanation: 'Se a relação é "tem um" (Carro TEM Motor), use composição. Herança é para "é um" (Cachorro É Animal).' },
  { id: 'q82', lessonId: 'm3-inheritance', question: 'No construtor da subclasse, a primeira linha deve ser:', options: ['this()', 'super() ou super(args)', 'return', 'new Pai()'], correct: 1, explanation: 'A primeira linha do construtor da subclasse deve chamar super(...) para inicializar a parte herdada.' },

  // M3 - Polymorphism
  { id: 'q85', lessonId: 'm3-polymorphism', question: 'O que é polimorfismo?', options: ['Muitas classes', 'Um método com comportamentos diferentes dependendo do objeto', 'Herança múltipla', 'Criar muitos objetos'], correct: 1, explanation: 'Polimorfismo = "muitas formas". O mesmo método se comporta diferentemente em cada subclasse.' },
  { id: 'q86', lessonId: 'm3-polymorphism', question: 'Para que serve @Override?', options: ['Criar um método novo', 'Indicar sobrescrita de método do pai', 'Tornar o método static', 'Ocultar o método do pai'], correct: 1, explanation: '@Override indica que o método está sobrescrevendo um método da superclasse. Ajuda a evitar erros de digitação.' },
  { id: 'q87', lessonId: 'm3-polymorphism', question: 'Animal a = new Cachorro(); a.emitirSom(); qual método roda?', options: ['O de Animal', 'O de Cachorro (objeto real)', 'Nenhum', 'Dá erro'], correct: 1, explanation: 'O Java escolhe o método pelo tipo do objeto em tempo de execução (polimorfismo).' },

  // M3 - Abstraction
  { id: 'q88', lessonId: 'm3-abstraction', question: 'Uma classe abstrata (abstract class) pode ser instanciada com new?', options: ['Sim', 'Não', 'Só no main', 'Só se tiver um método'], correct: 1, explanation: 'Classe abstrata não pode ser instanciada; só suas subclasses concretas.' },
  { id: 'q89', lessonId: 'm3-abstraction', question: 'Método abstract deve ter corpo (implementação)?', options: ['Sim', 'Não, só assinatura; a subclasse implementa', 'Opcional', 'Só em interface'], correct: 1, explanation: 'Método abstract não tem corpo; cada subclasse concreta implementa.' },
  { id: 'q89b', lessonId: 'm3-abstraction', question: 'Uma classe abstrata pode ter métodos concretos (com corpo)?', options: ['Não', 'Sim', 'Só um', 'Só static'], correct: 1, explanation: 'Pode misturar métodos abstract e métodos concretos na mesma classe abstrata.' },

  // M3 - Interfaces
  { id: 'q90', lessonId: 'm3-interfaces', question: 'Uma classe pode implementar múltiplas interfaces?', options: ['Não', 'Sim', 'Apenas 2', 'Apenas com abstract'], correct: 1, explanation: 'Java permite implementar MÚLTIPLAS interfaces, mas só pode estender UMA classe.' },
  { id: 'q91', lessonId: 'm3-interfaces', question: 'Quem implementa uma interface deve:', options: ['Só estender outra classe', 'Implementar todos os métodos declarados na interface', 'Usar abstract em todos', 'Não usar new'], correct: 1, explanation: 'A classe que implements deve fornecer implementação para todos os métodos da interface.' },
  { id: 'q92', lessonId: 'm3-interfaces', question: 'Interface em Java define principalmente:', options: ['Implementação', 'Contrato (quais métodos existirão)', 'Atributos privados', 'Construtores'], correct: 1, explanation: 'Interface define o contrato: assinaturas dos métodos que as implementações devem ter.' },

  // M3 - Composition
  { id: 'q93', lessonId: 'm3-composition', question: '"Carro tem um Motor" deve ser modelado com:', options: ['Herança (Carro extends Motor)', 'Composição (atributo Motor no Carro)', 'Interface', 'Classe abstrata'], correct: 1, explanation: '"Tem um" = composição (atributo). "É um" = herança.' },
  { id: 'q94', lessonId: 'm3-composition', question: 'Composição costuma ser mais flexível que herança porque:', options: ['É mais rápida', 'Permite trocar componentes e não cria acoplamento forte com a superclasse', 'Obriga a usar abstract', 'Não usa new'], correct: 1, explanation: 'Você pode trocar o componente (ex.: outro Motor) sem mudar a hierarquia de classes.' },
  { id: 'q95a', lessonId: 'm3-composition', question: 'Prefira composição a herança quando a relação for:', options: ['"é um"', '"tem um"', '"implementa"', '"estende"'], correct: 1, explanation: '"Tem um" → composição. "É um" → herança.' },

  // M3 - Overloading
  { id: 'q95b', lessonId: 'm3-overloading', question: 'Sobrecarga (overloading) é:', options: ['Mesmo nome, parâmetros diferentes, mesma classe', 'Mesmo nome na classe filha', 'Só para construtores', 'Herança'], correct: 0, explanation: 'Sobrecarga = vários métodos mesmo nome, parâmetros diferentes, na mesma classe.' },
  { id: 'q95c', lessonId: 'm3-overloading', question: 'Sobrescrita (overriding) é decidida em:', options: ['Compilação', 'Execução (polimorfismo)', 'Load da classe', 'Nunca'], correct: 1, explanation: 'A JVM escolhe qual método chamar em tempo de execução pelo tipo real do objeto.' },
  { id: 'q95d', lessonId: 'm3-overloading', question: 'Posso sobrecarregar mudando só o tipo de retorno?', options: ['Sim', 'Não, a lista de parâmetros deve ser diferente', 'Só com @Override', 'Só em interface'], correct: 1, explanation: 'Sobrecarga exige parâmetros diferentes; retorno sozinho não diferencia.' },

  // M3 - Access
  { id: 'q95e', lessonId: 'm3-access', question: 'private é acessível em:', options: ['Qualquer lugar', 'Apenas dentro da própria classe', 'No pacote', 'Nas subclasses'], correct: 1, explanation: 'private = só dentro da mesma classe.' },
  { id: 'q95f', lessonId: 'm3-access', question: 'protected permite acesso em:', options: ['Só na classe', 'Mesmo pacote ou subclasses', 'Só em subclasses', 'Em qualquer arquivo'], correct: 1, explanation: 'protected = mesma classe, mesmo pacote e subclasses (mesmo em outro pacote).' },
  { id: 'q95g', lessonId: 'm3-access', question: 'Modificador default (nenhum) permite acesso em:', options: ['Qualquer lugar', 'Apenas no mesmo pacote', 'Só na classe', 'Só em subclasses'], correct: 1, explanation: 'Sem modificador = visibilidade de pacote (package-private).' },

  // M3 - Exceptions
  { id: 'q95', lessonId: 'm3-exceptions', question: 'O bloco finally sempre executa?', options: ['Não, só quando há erro', 'Sim, com ou sem exceção', 'Apenas se não houver catch', 'Apenas com exceções checked'], correct: 1, explanation: 'finally sempre executa, independentemente de ter ocorrido exceção ou não. Útil para cleanup.' },
  { id: 'q96', lessonId: 'm3-exceptions', question: 'Exceções checked (ex.: IOException) devem ser:', options: ['Ignoradas', 'Tratadas com try/catch ou declaradas com throws', 'Só em main', 'Convertidas em unchecked'], correct: 1, explanation: 'Checked exceptions obrigam tratamento ou declaração throws.' },
  { id: 'q97', lessonId: 'm3-exceptions', question: 'NullPointerException é checked ou unchecked?', options: ['Checked', 'Unchecked (RuntimeException)', 'Ambos', 'Nenhum'], correct: 1, explanation: 'RuntimeException e subclasses são unchecked; não obrigam try/catch.' },

  // M3 - SOLID
  { id: 'q98', lessonId: 'm3-solid', question: 'SRP (Single Responsibility) significa:', options: ['Uma classe faz tudo', 'Uma classe deve ter apenas uma razão para mudar', 'Só um método por classe', 'Só um atributo'], correct: 1, explanation: 'Cada classe com uma responsabilidade bem definida.' },
  { id: 'q99', lessonId: 'm3-solid', question: 'Open/Closed prega:', options: ['Abrir e fechar arquivos', 'Aberta para extensão, fechada para modificação', 'Só uma subclasse', 'Código fechado'], correct: 1, explanation: 'Estender com novas classes sem modificar o código existente.' },
  { id: 'q100', lessonId: 'm3-solid', question: 'Dependency Inversion: devemos depender de:', options: ['Classes concretas só', 'Abstrações (interfaces/classes abstratas)', 'Só de static', 'Do main'], correct: 1, explanation: 'Depender de abstrações permite trocar implementações sem quebrar o código.' },

  // M3 - Project
  { id: 'q101', lessonId: 'm3-project', question: 'No projeto final, Exibivel é:', options: ['Classe abstrata', 'Interface (contrato)', 'Classe concreta', 'Método'], correct: 1, explanation: 'Interface que define o contrato exibir().' },
  { id: 'q102', lessonId: 'm3-project', question: 'ItemCadastro é classe abstrata porque:', options: ['Não tem métodos', 'Tem método abstrato (ex.: calcularValor) e não deve ser instanciada diretamente', 'É interface', 'É final'], correct: 1, explanation: 'Define comportamento base e obriga subclasses a implementar calcularValor().' },
  { id: 'q103', lessonId: 'm3-project', question: 'Produto estende ItemCadastro e implementa Exibivel. Isso usa:', options: ['Só herança', 'Herança e interface (reuso + contrato)', 'Só interface', 'Nada'], correct: 1, explanation: 'extends para herdar ItemCadastro; implements para o contrato Exibivel.' },
];
