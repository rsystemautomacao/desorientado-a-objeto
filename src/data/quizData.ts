import { QuizQuestion } from './types';

export const quizQuestions: QuizQuestion[] = [
  // M1 - Intro
  { id: 'q1', lessonId: 'm1-intro', question: 'O que é a JVM?', options: ['Um editor de código Java', 'A máquina virtual que executa bytecode Java', 'O compilador Java', 'Uma biblioteca do Java'], correct: 1, explanation: 'JVM (Java Virtual Machine) é a máquina virtual que interpreta e executa o bytecode (.class) gerado pelo compilador javac.' },
  { id: 'q2', lessonId: 'm1-intro', question: 'Qual é o ponto de entrada de um programa Java?', options: ['A primeira linha do arquivo', 'O método start()', 'O método main(String[] args)', 'O construtor da classe'], correct: 2, explanation: 'O método public static void main(String[] args) é o ponto de entrada de todo programa Java.' },
  { id: 'q3', lessonId: 'm1-intro', question: 'Qual comando compila um arquivo Java?', options: ['java MeuPrograma.java', 'javac MeuPrograma.java', 'compile MeuPrograma.java', 'run MeuPrograma.java'], correct: 1, explanation: 'O comando javac (Java Compiler) compila o código-fonte .java em bytecode .class.' },
  { id: 'q4', lessonId: 'm1-intro', question: 'System.out.println() faz o quê?', options: ['Lê entrada do usuário', 'Imprime e pula linha', 'Imprime sem pular linha', 'Cria uma variável'], correct: 1, explanation: 'println() imprime o texto e pula uma linha. print() imprime sem pular linha.' },
  { id: 'q5', lessonId: 'm1-intro', question: 'Qual a diferença entre JDK e JRE?', options: ['São a mesma coisa', 'JDK é para desenvolver, JRE é para executar', 'JRE é para desenvolver, JDK é para executar', 'JDK é mais antigo que JRE'], correct: 1, explanation: 'JDK (Development Kit) contém ferramentas de desenvolvimento + JRE. JRE (Runtime Environment) contém apenas o necessário para executar.' },
  { id: 'q6', lessonId: 'm1-intro', question: 'Qual a saída deste código?\nSystem.out.print("A");\nSystem.out.println("B");\nSystem.out.print("C");', code: 'System.out.print("A");\nSystem.out.println("B");\nSystem.out.print("C");', options: ['A B C', 'AB\\nC', 'ABC', 'A\\nB\\nC'], correct: 1, explanation: 'print("A") imprime A sem pular. println("B") imprime B e pula linha. print("C") imprime C. Resultado: AB(nova linha)C.' },

  // M1 - Variables
  { id: 'q10', lessonId: 'm1-variables', question: 'Qual tipo primitivo é mais usado para números inteiros?', options: ['byte', 'short', 'int', 'long'], correct: 2, explanation: 'int é o tipo padrão para inteiros em Java, com alcance de aproximadamente -2 bilhões a 2 bilhões.' },
  { id: 'q11', lessonId: 'm1-variables', question: 'Como comparar o conteúdo de duas Strings?', options: ['str1 == str2', 'str1.equals(str2)', 'str1.compare(str2)', 'str1 === str2'], correct: 1, explanation: '== compara referências (endereço na memória). .equals() compara o conteúdo real da String.' },
  { id: 'q12', lessonId: 'm1-variables', question: 'O que acontece em: int x = (int) 9.7;', options: ['x = 10 (arredonda)', 'x = 9 (trunca)', 'Erro de compilação', 'x = 9.7'], correct: 1, explanation: 'Casting de double para int TRUNCA (corta a parte decimal), não arredonda. 9.7 vira 9.' },
  { id: 'q13', lessonId: 'm1-variables', question: 'Qual declaração está CORRETA?', options: ['float x = 3.14;', 'float x = 3.14f;', 'float x = 3.14d;', 'Float x = 3.14;'], correct: 1, explanation: 'Literais decimais são double por padrão. Para float, adicione f: 3.14f.' },
  { id: 'q14', lessonId: 'm1-variables', question: 'String é um tipo primitivo?', options: ['Sim', 'Não, é um tipo de referência (objeto)', 'Depende do contexto', 'Sim, mas só a partir do Java 11'], correct: 1, explanation: 'String é uma classe (tipo de referência), não um tipo primitivo. Os 8 primitivos são: byte, short, int, long, float, double, char, boolean.' },
  { id: 'q15', lessonId: 'm1-variables', question: 'Qual é o valor padrão de uma variável boolean?', options: ['true', 'false', 'null', '0'], correct: 1, explanation: 'Variáveis boolean de instância (atributos) têm valor padrão false. Variáveis locais precisam ser inicializadas.' },

  // M1 - Arrays
  { id: 'q20', lessonId: 'm1-arrays', question: 'Qual o índice do primeiro elemento de um array?', options: ['1', '0', '-1', 'Depende do tamanho'], correct: 1, explanation: 'Arrays em Java (e na maioria das linguagens) começam no índice 0.' },
  { id: 'q21', lessonId: 'm1-arrays', question: 'O que acontece ao acessar array[array.length]?', options: ['Retorna o último elemento', 'Retorna null', 'ArrayIndexOutOfBoundsException', 'Retorna 0'], correct: 2, explanation: 'O último índice válido é array.length - 1. Acessar array.length causa ArrayIndexOutOfBoundsException.' },
  { id: 'q22', lessonId: 'm1-arrays', question: 'Qual a diferença entre .length e .length()?', options: ['São iguais', '.length para arrays, .length() para Strings', '.length() para arrays, .length para Strings', 'Nenhuma, ambos funcionam para tudo'], correct: 1, explanation: 'Arrays usam .length (propriedade, sem parênteses). Strings usam .length() (método, com parênteses).' },
  { id: 'q23', lessonId: 'm1-arrays', question: 'int[] nums = {5, 10, 15}; Qual o valor de nums[1]?', options: ['5', '10', '15', 'Erro'], correct: 1, explanation: 'Índice 0 = 5, índice 1 = 10, índice 2 = 15.' },
  { id: 'q24', lessonId: 'm1-arrays', question: 'Qual loop é preferível quando NÃO precisamos do índice?', options: ['for clássico', 'while', 'for-each (for : )', 'do-while'], correct: 2, explanation: 'O for-each (for (int x : array)) é mais limpo e menos propenso a erros quando não precisamos do índice.' },
  { id: 'q24b', lessonId: 'm1-arrays', question: 'Qual método de java.util.Arrays ordena um array?', options: ['Arrays.order()', 'Arrays.sort()', 'Arrays.arrange()', 'array.sort()'], correct: 1, explanation: 'Arrays.sort(array) ordena o array em ordem crescente. É um método estático da classe java.util.Arrays.' },

  // M1 - Loops
  { id: 'q30', lessonId: 'm1-loops', question: 'Qual loop garante pelo menos uma execução?', options: ['for', 'while', 'do-while', 'for-each'], correct: 2, explanation: 'O do-while executa o bloco primeiro e depois verifica a condição. Garante pelo menos uma execução.' },
  { id: 'q31', lessonId: 'm1-loops', question: 'O que o break faz dentro de um loop?', options: ['Pula para a próxima iteração', 'Encerra o loop imediatamente', 'Pausa a execução por 1 segundo', 'Reinicia o loop'], correct: 1, explanation: 'break encerra o loop imediatamente. continue pula para a próxima iteração.' },
  { id: 'q32', lessonId: 'm1-loops', question: 'Qual a saída?\nfor (int i = 0; i < 3; i++) {\n  System.out.print(i + " ");\n}', code: 'for (int i = 0; i < 3; i++) {\n  System.out.print(i + " ");\n}', options: ['1 2 3', '0 1 2', '0 1 2 3', '1 2'], correct: 1, explanation: 'i começa em 0 e vai até 2 (i < 3). Imprime: 0 1 2.' },
  { id: 'q34', lessonId: 'm1-loops', question: 'O que o continue faz dentro de um loop?', options: ['Encerra o loop', 'Pula para a próxima iteração', 'Pausa a execução', 'Reinicia o loop do zero'], correct: 1, explanation: 'continue pula o restante do corpo do loop e vai para a próxima iteração. Diferente do break, que encerra o loop.' },
  { id: 'q35', lessonId: 'm1-loops', question: 'Qual loop é mais adequado quando NÃO sabemos quantas vezes vamos repetir?', options: ['for', 'while', 'for-each', 'Nenhum'], correct: 1, explanation: 'while é ideal quando a repetição depende de uma condição e não sabemos previamente quantas iterações serão. for é melhor quando sabemos o número de iterações.' },
  { id: 'q36', lessonId: 'm1-loops', question: 'Qual a saída?\nfor (int i = 0; i < 5; i++) {\n  if (i == 3) break;\n  System.out.print(i + " ");\n}', code: 'for (int i = 0; i < 5; i++) {\n  if (i == 3) break;\n  System.out.print(i + " ");\n}', options: ['0 1 2 3 4', '0 1 2', '0 1 2 4', '3'], correct: 1, explanation: 'Quando i chega a 3, o break encerra o loop imediatamente. Os valores impressos são: 0 1 2.' },

  // M1 - if/else
  { id: 'q40', lessonId: 'm1-ifelse', question: 'Qual operador ternário está correto?', options: ['x > 5 : "sim" ? "não"', 'x > 5 ? "sim" : "não"', 'x > 5 ?? "sim" :: "não"', '(x > 5) -> "sim" | "não"'], correct: 1, explanation: 'A sintaxe do ternário é: condição ? valorTrue : valorFalse.' },
  { id: 'q41', lessonId: 'm1-ifelse', question: 'if (x = 5) — o que está errado?', options: ['Nada, está correto', 'Usa = (atribuição) ao invés de == (comparação)', 'Faltam chaves', 'x não foi declarado'], correct: 1, explanation: '= é atribuição (define valor). == é comparação (verifica igualdade). No if, use ==.' },
  { id: 'q42', lessonId: 'm1-ifelse', question: 'Para que serve o else if?', options: ['Substituir o switch', 'Testar outra condição quando a anterior for false', 'Criar um loop', 'Encerrar o programa'], correct: 1, explanation: 'else if permite encadear múltiplas condições. Se o primeiro if for false, testa o else if, e assim por diante.' },
  { id: 'q43', lessonId: 'm1-ifelse', question: 'Qual a saída?\nint x = 10;\nif (x > 5) {\n  System.out.print("A");\n} else if (x > 8) {\n  System.out.print("B");\n}', code: 'int x = 10;\nif (x > 5) {\n  System.out.print("A");\n} else if (x > 8) {\n  System.out.print("B");\n}', options: ['AB', 'A', 'B', 'Nenhuma saída'], correct: 1, explanation: 'O primeiro if (x > 5) é true, então imprime "A". O else if NÃO é avaliado porque o if anterior já foi true. Em cadeia if/else, apenas UM bloco executa.' },
  { id: 'q44', lessonId: 'm1-ifelse', question: 'O que acontece se NÃO usar chaves {} no if com duas linhas de código?', options: ['Funciona normalmente', 'Apenas a primeira linha pertence ao if; a segunda sempre executa', 'Erro de compilação', 'As duas linhas pertencem ao if'], correct: 1, explanation: 'Sem chaves, apenas a PRIMEIRA instrução faz parte do if. As demais executam sempre, independente da condição. Sempre use chaves para evitar bugs.' },
  { id: 'q44b', lessonId: 'm1-ifelse', question: 'Qual expressão correta do operador ternário para: se nota >= 7, "Aprovado", senão "Reprovado"?', options: ['nota >= 7 : "Aprovado" ? "Reprovado"', 'nota >= 7 ? "Aprovado" : "Reprovado"', 'nota >= 7 && "Aprovado" || "Reprovado"', 'if nota >= 7 then "Aprovado" else "Reprovado"'], correct: 1, explanation: 'Sintaxe do ternário: condição ? valorTrue : valorFalse. Neste caso: nota >= 7 ? "Aprovado" : "Reprovado".' },

  // M1 - Switch
  { id: 'q45', lessonId: 'm1-switch', question: 'O que acontece se esquecer o break num case?', options: ['Erro de compilação', 'Fall-through: executa os cases seguintes', 'O switch para', 'Volta ao primeiro case'], correct: 1, explanation: 'Sem break, a execução "cai" para o próximo case (fall-through). Geralmente é um bug.' },
  { id: 'q46', lessonId: 'm1-switch', question: 'O switch pode ser usado com String?', options: ['Não, apenas com int', 'Sim, a partir do Java 7', 'Apenas com enum', 'Não em Java'], correct: 1, explanation: 'A partir do Java 7, switch aceita String na variável.' },
  { id: 'q47', lessonId: 'm1-switch', question: 'Para que serve o default no switch?', options: ['É obrigatório', 'É executado quando nenhum case corresponde', 'Reinicia o switch', 'Define o valor padrão da variável'], correct: 1, explanation: 'default é como o "else": executado quando nenhum case corresponde ao valor.' },
  { id: 'q48', lessonId: 'm1-switch', question: 'Quais tipos o switch NÃO aceita em Java?', options: ['String e int', 'double, float e boolean', 'char e byte', 'int e enum'], correct: 1, explanation: 'switch aceita: byte, short, int, char, String (Java 7+) e enum. NÃO aceita: double, float, long e boolean.' },
  { id: 'q49', lessonId: 'm1-switch', question: 'Qual a saída?\nint x = 2;\nswitch(x) {\n  case 1: System.out.print("A");\n  case 2: System.out.print("B");\n  case 3: System.out.print("C");\n}', code: 'int x = 2;\nswitch(x) {\n  case 1: System.out.print("A");\n  case 2: System.out.print("B");\n  case 3: System.out.print("C");\n}', options: ['B', 'BC', 'ABC', 'C'], correct: 1, explanation: 'Sem break, ocorre fall-through: após o case 2 executar, o case 3 também executa. Resultado: BC.' },
  { id: 'q49b', lessonId: 'm1-switch', question: 'Quando o switch é mais indicado que if/else?', options: ['Sempre', 'Quando temos muitas comparações de igualdade com uma mesma variável', 'Quando usamos operadores como > e <', 'Nunca, são iguais'], correct: 1, explanation: 'switch é ideal para comparar UMA variável com vários valores fixos. Para condições com intervalos (>, <, >=), use if/else.' },

  // M1 - Matrices
  { id: 'q25', lessonId: 'm1-matrices', question: 'O que é uma matriz em Java?', options: ['Um array de uma dimensão', 'Um array de arrays (2D)', 'Um tipo primitivo', 'Uma classe especial'], correct: 1, explanation: 'Matriz é um array bidimensional: int[][] — cada elemento é um array.' },
  { id: 'q26', lessonId: 'm1-matrices', question: 'Como acessar o elemento da linha 1, coluna 2?', options: ['matriz(1, 2)', 'matriz[1][2]', 'matriz.get(1, 2)', 'matriz[2][1]'], correct: 1, explanation: 'Acesso é por colchetes: matriz[linha][coluna]. Índices começam em 0.' },
  { id: 'q27', lessonId: 'm1-matrices', question: 'matriz.length retorna o quê?', options: ['Número total de elementos', 'Número de colunas', 'Número de linhas', 'O tamanho em memória'], correct: 2, explanation: 'Em uma matriz 2D, matriz.length é o número de linhas (quantos arrays ela contém).' },
  { id: 'q27b', lessonId: 'm1-matrices', question: 'Como obter o número de colunas da linha i?', options: ['matriz.length', 'matriz[i].length', 'matriz.width', 'matriz[i].size()'], correct: 1, explanation: 'matriz.length = número de linhas. matriz[i].length = número de colunas da linha i. Em Java, cada linha pode ter tamanho diferente (jagged array).' },
  { id: 'q27c', lessonId: 'm1-matrices', question: 'Para percorrer toda uma matriz 2D, precisamos de:', options: ['Um loop simples', 'Dois loops aninhados (linhas e colunas)', 'Três loops', 'Um for-each apenas'], correct: 1, explanation: 'O loop externo percorre as linhas e o loop interno percorre as colunas de cada linha. Ex: for(i) { for(j) { matriz[i][j] } }' },
  { id: 'q27d', lessonId: 'm1-matrices', question: 'int[][] m = new int[3][4]; quantos elementos essa matriz armazena?', options: ['3', '4', '7', '12'], correct: 3, explanation: '3 linhas × 4 colunas = 12 elementos no total.' },

  // M1 - Functions
  { id: 'q28', lessonId: 'm1-functions', question: 'O que significa void em um método?', options: ['O método retorna 0', 'O método não retorna valor', 'O método é vazio', 'O método é opcional'], correct: 1, explanation: 'void indica que o método não retorna nenhum valor.' },
  { id: 'q29', lessonId: 'm1-functions', question: 'O que é sobrecarga de método?', options: ['Método com muitos parâmetros', 'Vários métodos com o mesmo nome e parâmetros diferentes', 'Método que chama a si mesmo', 'Método que retorna sobrecarga'], correct: 1, explanation: 'Sobrecarga (overloading): mesmo nome, lista de parâmetros diferente na mesma classe.' },
  { id: 'q33', lessonId: 'm1-functions', question: 'Onde variáveis locais existem?', options: ['Em todo o programa', 'Apenas dentro do método onde foram declaradas', 'Em todas as classes', 'Em arquivos .java'], correct: 1, explanation: 'Variáveis declaradas dentro de um método são locais a esse método e deixam de existir quando ele termina.' },
  { id: 'q33b', lessonId: 'm1-functions', question: 'Qual a diferença entre parâmetro e argumento?', options: ['São a mesma coisa', 'Parâmetro é a variável na declaração; argumento é o valor passado na chamada', 'Argumento é na declaração; parâmetro na chamada', 'Parâmetro é para void, argumento é para retorno'], correct: 1, explanation: 'Parâmetro: variável na assinatura do método (ex: int x). Argumento: valor real passado ao chamar (ex: somar(5, 3)).' },
  { id: 'q33c', lessonId: 'm1-functions', question: 'O que acontece quando um método executa return?', options: ['O programa encerra', 'O método para imediatamente e devolve o valor ao chamador', 'O loop mais próximo para', 'Nada especial'], correct: 1, explanation: 'return encerra o método e devolve o valor especificado. Código após o return no mesmo bloco não é executado.' },
  { id: 'q33d', lessonId: 'm1-functions', question: 'Posso ter dois métodos chamados "calcular" na mesma classe?', options: ['Não, dá erro', 'Sim, se tiverem parâmetros diferentes (sobrecarga)', 'Só se um for void', 'Só se forem static'], correct: 1, explanation: 'Sobrecarga (overloading) permite métodos com o mesmo nome desde que a lista de parâmetros seja diferente (tipo, quantidade ou ordem).' },

  // M1 - Operators
  { id: 'q50', lessonId: 'm1-operators', question: 'Qual o resultado de 10 / 3 em Java (inteiros)?', options: ['3.33', '3', '4', '3.0'], correct: 1, explanation: 'Divisão entre inteiros resulta em inteiro. 10 / 3 = 3 (truncado). Para decimal: 10.0 / 3 = 3.33...' },
  { id: 'q51', lessonId: 'm1-operators', question: 'O que o operador % retorna?', options: ['A divisão', 'O quociente', 'O resto da divisão', 'A porcentagem'], correct: 2, explanation: '% (módulo) retorna o RESTO da divisão inteira. Ex: 10 % 3 = 1.' },
  { id: 'q52', lessonId: 'm1-operators', question: 'Qual a diferença entre ++i e i++?', options: ['São iguais', '++i incrementa antes de usar; i++ usa e depois incrementa', '++i é mais rápido', 'i++ é para loops, ++i é para if'], correct: 1, explanation: '++i (pré-incremento) incrementa primeiro e depois retorna o valor. i++ (pós-incremento) retorna o valor atual e depois incrementa. Ex: int i = 5; System.out.print(i++); imprime 5, e depois i vira 6.' },
  { id: 'q53', lessonId: 'm1-operators', question: 'O que o operador && faz se a primeira condição for false?', options: ['Avalia a segunda condição mesmo assim', 'Não avalia a segunda condição (curto-circuito)', 'Dá erro', 'Retorna null'], correct: 1, explanation: '&& (AND lógico) usa curto-circuito: se a primeira condição for false, já sabe que o resultado é false e NÃO avalia a segunda. Útil para evitar NullPointerException.' },
  { id: 'q54', lessonId: 'm1-operators', question: 'Qual o resultado de: 2 + 3 * 4?', options: ['20', '14', '12', '24'], correct: 1, explanation: 'Multiplicação (*) tem precedência sobre adição (+). Primeiro: 3 * 4 = 12, depois 2 + 12 = 14. Para mudar a ordem: (2 + 3) * 4 = 20.' },
  { id: 'q55', lessonId: 'm1-operators', question: 'Qual operador verifica se dois valores são DIFERENTES?', options: ['<>', '!=', '!==', 'not'], correct: 1, explanation: '!= é o operador "diferente de" em Java. Retorna true se os valores forem diferentes.' },

  // M2 - I/O (Scanner)
  { id: 'qm2-1', lessonId: 'm2-io', question: 'Por que chamar nextLine() após nextInt() ou nextDouble()?', options: ['Para fechar o Scanner', 'Para limpar o buffer e evitar pular a próxima leitura', 'É obrigatório em Java', 'Para ler a próxima linha'], correct: 1, explanation: 'O Enter digitado após o número fica no buffer. Sem nextLine(), o próximo nextLine() consome essa linha vazia.' },
  { id: 'qm2-2', lessonId: 'm2-io', question: 'Qual método do Scanner lê uma linha inteira?', options: ['next()', 'nextLine()', 'nextString()', 'readLine()'], correct: 1, explanation: 'nextLine() lê até a quebra de linha. next() lê até o próximo espaço ou fim de linha.' },
  { id: 'qm2-3', lessonId: 'm2-io', question: 'Para ler dados do teclado, o Scanner é criado com:', options: ['new Scanner(File)', 'new Scanner(System.in)', 'new Scanner(Keyboard)', 'Scanner.create()'], correct: 1, explanation: 'System.in é o fluxo de entrada padrão (teclado).' },
  { id: 'qm2-1b', lessonId: 'm2-io', question: 'Qual a diferença entre next() e nextLine()?', options: ['São iguais', 'next() lê até o espaço; nextLine() lê a linha inteira', 'nextLine() lê até o espaço', 'next() é mais novo'], correct: 1, explanation: 'next() lê até o próximo espaço ou quebra de linha. nextLine() lê toda a linha até a quebra de linha.' },
  { id: 'qm2-1c', lessonId: 'm2-io', question: 'Qual o formato correto para imprimir "Preço: R$ 9.99" com printf?', options: ['System.out.printf("Preço: R$ %d", 9.99)', 'System.out.printf("Preço: R$ %.2f", 9.99)', 'System.out.printf("Preço: R$ %s", 9.99)', 'System.out.println("Preço: R$ " + 9.99f)'], correct: 1, explanation: '%.2f formata um double com 2 casas decimais. %d é para inteiros, %s é para Strings.' },
  { id: 'qm2-1d', lessonId: 'm2-io', question: 'O que acontece se o usuário digitar "abc" quando o programa espera nextInt()?', options: ['Converte para 0', 'InputMismatchException', 'O programa ignora', 'Lê como String'], correct: 1, explanation: 'Se o tipo digitado não corresponde ao esperado, o Scanner lança InputMismatchException.' },

  // M2 - Strings
  { id: 'qm2-4', lessonId: 'm2-strings', question: 'Strings em Java são imutáveis. Isso significa:', options: ['Não podem ser usadas', 'Métodos como trim() retornam uma nova String, a original não muda', 'Só podem ser criadas uma vez', 'Não podem ser comparadas'], correct: 1, explanation: 'Imutável = o conteúdo do objeto não muda. Operações retornam novos objetos.' },
  { id: 'qm2-5', lessonId: 'm2-strings', question: 'Para concatenar muitas strings em um loop, o mais eficiente é:', options: ['Usar + em cada iteração', 'StringBuilder', 'String.concat() em cada iteração', 'Arrays de char'], correct: 1, explanation: 'StringBuilder evita criar dezenas de objetos String intermediários.' },
  { id: 'qm2-6', lessonId: 'm2-strings', question: '"a,b,c".split(",") retorna:', options: ['Uma String', 'Um array String[] com três elementos', 'Um ArrayList', 'Um char[]'], correct: 1, explanation: 'split() divide a String e retorna um array de Strings.' },
  { id: 'qm2-4b', lessonId: 'm2-strings', question: '" Hello ".trim() retorna:', options: ['" Hello "', '"Hello"', '" Hello"', '"Hello "'], correct: 1, explanation: 'trim() remove espaços em branco do início e do fim da String. Espaços internos são mantidos.' },
  { id: 'qm2-4c', lessonId: 'm2-strings', question: 'Por que usar .equals() ao invés de == para comparar Strings?', options: ['São iguais', '== compara referências (endereço); .equals() compara conteúdo', '== é mais lento', '.equals() é obrigatório'], correct: 1, explanation: '== verifica se duas variáveis apontam para o MESMO objeto na memória. .equals() verifica se o CONTEÚDO é igual, que é o que geralmente queremos.' },
  { id: 'qm2-4d', lessonId: 'm2-strings', question: '"Java".charAt(0) retorna:', options: ['"J"', '\'J\'', '74', '"Java"'], correct: 1, explanation: 'charAt(index) retorna o caractere (char) na posição especificada. Índice 0 = primeiro caractere = \'J\'.' },

  // M2 - Debug
  { id: 'qm2-7', lessonId: 'm2-debug', question: 'No stack trace, a primeira linha "at arquivo.java:10" indica:', options: ['A linha 10 do arquivo onde o erro ocorreu', 'O número de erros', 'A versão do Java', 'O nome do projeto'], correct: 0, explanation: 'Indica o arquivo e o número da linha onde a exceção foi lançada.' },
  { id: 'qm2-8', lessonId: 'm2-debug', question: 'NullPointerException geralmente significa:', options: ['Array vazio', 'Chamou método ou acessou campo em uma referência null', 'Divisão por zero', 'Arquivo não encontrado'], correct: 1, explanation: 'Alguma variável está null e você tentou usá-la (método ou campo).' },
  { id: 'qm2-9', lessonId: 'm2-debug', question: 'ArrayIndexOutOfBoundsException indica:', options: ['O array é null', 'Você acessou um índice fora do tamanho do array', 'O array está vazio', 'Tipo errado no array'], correct: 1, explanation: 'Ex.: acessar índice 5 em um array de tamanho 3.' },
  { id: 'qm2-7b', lessonId: 'm2-debug', question: 'Qual a diferença entre erro de compilação e erro de execução?', options: ['São iguais', 'Compilação: detectado pelo javac antes de rodar; Execução: ocorre durante a execução', 'Execução é detectado pelo javac', 'Compilação ocorre em runtime'], correct: 1, explanation: 'Erros de compilação (sintaxe, tipos) são detectados pelo compilador javac. Erros de execução (exceções) ocorrem quando o programa já está rodando.' },
  { id: 'qm2-7c', lessonId: 'm2-debug', question: 'No stack trace, as linhas são listadas de cima para baixo. A de cima é:', options: ['A causa raiz', 'O ponto exato onde o erro ocorreu', 'O método main', 'A classe principal'], correct: 1, explanation: 'A primeira linha "at ..." mostra onde o erro aconteceu. As linhas abaixo mostram a cadeia de chamadas (quem chamou quem) até chegar ao main.' },
  { id: 'qm2-7d', lessonId: 'm2-debug', question: 'System.out.println() pode ser usado para debug?', options: ['Não, só debuggers servem', 'Sim, é a forma mais simples de inspecionar valores durante execução', 'Só em modo debug', 'Só com IDE'], correct: 1, explanation: 'Imprimir valores com println() é a técnica mais básica de debug. Permite verificar o estado das variáveis em diferentes pontos do código.' },

  // M2 - Collections
  { id: 'qm2-10', lessonId: 'm2-collections', question: 'Qual a principal vantagem do ArrayList em relação ao array?', options: ['É mais rápido', 'Tamanho dinâmico: pode adicionar e remover elementos', 'Usa menos memória', 'Só aceita objetos'], correct: 1, explanation: 'Array tem tamanho fixo; ArrayList cresce e diminui conforme necessário.' },
  { id: 'qm2-11', lessonId: 'm2-collections', question: 'Por que não podemos usar ArrayList<int>?', options: ['Podemos, é válido', 'Generics em Java não aceitam tipos primitivos; use ArrayList<Integer>', 'int não existe em Java', 'ArrayList só aceita String'], correct: 1, explanation: 'Generics trabalham apenas com tipos de referência (objetos).' },
  { id: 'qm2-12', lessonId: 'm2-collections', question: 'Para obter o número de elementos em um ArrayList lista:', options: ['lista.length', 'lista.length()', 'lista.size()', 'lista.count()'], correct: 2, explanation: 'ArrayList usa size(); arrays usam length.' },
  { id: 'qm2-10b', lessonId: 'm2-collections', question: 'Como remover um elemento do ArrayList por índice?', options: ['lista.delete(0)', 'lista.remove(0)', 'lista.pop(0)', 'lista[0] = null'], correct: 1, explanation: 'remove(index) remove o elemento na posição indicada e rearranja os demais. remove(Object) remove pela igualdade do objeto.' },
  { id: 'qm2-10c', lessonId: 'm2-collections', question: 'Qual a sintaxe correta para criar um ArrayList de Strings?', options: ['ArrayList<String> lista = new ArrayList<String>();', 'ArrayList lista = new ArrayList<string>();', 'List<string> lista = new List<>();', 'ArrayList[String] lista = new ArrayList();'], correct: 0, explanation: 'A forma correta usa generics com o tipo entre < >: ArrayList<String>. O diamond operator <> no new é opcional desde Java 7.' },
  { id: 'qm2-10d', lessonId: 'm2-collections', question: 'lista.contains("Java") retorna:', options: ['O índice do elemento', 'true se "Java" estiver na lista, false caso contrário', 'O elemento encontrado', 'O número de ocorrências'], correct: 1, explanation: 'contains() verifica a presença do elemento e retorna boolean (true/false).' },

  // M2 - Packages
  { id: 'qm2-13', lessonId: 'm2-packages', question: 'A declaração package no arquivo Java deve estar:', options: ['No final do arquivo', 'Na primeira linha útil do arquivo (após comentários)', 'Dentro da classe', 'No import'], correct: 1, explanation: 'package é a primeira instrução do arquivo (comentários podem vir antes).' },
  { id: 'qm2-14', lessonId: 'm2-packages', question: 'Para usar a classe ArrayList de outro pacote, usamos:', options: ['package java.util.ArrayList', 'import java.util.ArrayList;', 'include java.util.ArrayList', 'require java.util.ArrayList'], correct: 1, explanation: 'import traz a classe para o escopo do arquivo.' },
  { id: 'qm2-15', lessonId: 'm2-packages', question: 'A convenção de nomes para pacotes em Java é:', options: ['PascalCase', 'geralmente minúsculo, ex: com.empresa.projeto', 'UPPER_SNAKE', 'camelCase'], correct: 1, explanation: 'Pacotes são em minúsculas; múltiplas palavras em um nível podem usar algo como com.empresa.meuProjeto.' },
  { id: 'qm2-13b', lessonId: 'm2-packages', question: 'O que import java.util.*; faz?', options: ['Importa TODAS as classes do Java', 'Importa todas as classes do pacote java.util', 'Importa apenas ArrayList', 'Dá erro de compilação'], correct: 1, explanation: 'O asterisco (*) importa todas as classes de um pacote específico. Não importa sub-pacotes. É conveniente mas pode poluir o namespace.' },
  { id: 'qm2-13c', lessonId: 'm2-packages', question: 'Classes do pacote java.lang (como String, Math) precisam de import?', options: ['Sim, sempre', 'Não, java.lang é importado automaticamente', 'Só em projetos grandes', 'Depende da IDE'], correct: 1, explanation: 'java.lang é o único pacote importado automaticamente em todo programa Java. Por isso usamos String, System, Math sem import.' },
  { id: 'qm2-13d', lessonId: 'm2-packages', question: 'Duas classes com mesmo nome em pacotes diferentes — como usar ambas?', options: ['Impossível em Java', 'Usar o nome completo (fully qualified) em pelo menos uma delas', 'Renomear uma classe', 'Usar alias com as'], correct: 1, explanation: 'Exemplo: java.util.Date e java.sql.Date. Importe uma e use o nome completo na outra: java.sql.Date sqlDate = new java.sql.Date(...).' },

  // M3 - POO (O que é POO e Por Que Existe)
  { id: 'q60', lessonId: 'm3-whatispoo', question: 'Quais são os 4 pilares da POO?', options: ['Variáveis, Funções, Arrays, Loops', 'Classe, Objeto, Método, Atributo', 'Encapsulamento, Herança, Polimorfismo, Abstração', 'public, private, protected, static'], correct: 2, explanation: 'Os 4 pilares da POO são: Encapsulamento (proteger dados), Herança (reaproveitar código), Polimorfismo (mesmo método, comportamento diferente) e Abstração (definir o que, não como).' },
  { id: 'q61', lessonId: 'm3-whatispoo', question: 'Por que usamos "private" nos atributos de uma classe?', options: ['Para o código compilar mais rápido', 'Para impedir acesso direto e forçar o uso de métodos com validação', 'Porque o Java exige que tudo seja private', 'Para poder usar static'], correct: 1, explanation: 'Atributos private só podem ser acessados dentro da própria classe. Para alterar, precisa usar métodos (como depositar, vender), que fazem validação antes. Isso é Encapsulamento.' },
  { id: 'q62', lessonId: 'm3-whatispoo', question: 'No código procedural, o que tende a acontecer quando o sistema cresce?', options: ['Fica mais rápido', 'Dados e regras ficam espalhados, difícil de manter', 'O compilador otimiza sozinho', 'Só funciona em Java'], correct: 1, explanation: 'Sem POO, funções e dados soltos tornam o código frágil e difícil de manter quando o sistema cresce. Variáveis podem ser alteradas sem validação de qualquer lugar.' },
  { id: 'q62b', lessonId: 'm3-whatispoo', question: 'Após sc.nextInt(), o que acontece se chamar sc.nextLine() logo em seguida?', options: ['Lê o próximo texto normalmente', 'Lê uma string vazia (o Enter que sobrou no buffer)', 'Dá erro de compilação', 'O programa trava'], correct: 1, explanation: 'nextInt() lê o número mas deixa o Enter no buffer. O nextLine() seguinte consome esse Enter e retorna "". Solução: colocar um sc.nextLine() extra entre eles para limpar o buffer.' },
  { id: 'q62c', lessonId: 'm3-whatispoo', question: 'Qual a diferença entre Classe e Objeto?', options: ['São a mesma coisa', 'Classe é o molde/receita, Objeto é a instância criada com new', 'Objeto é o molde, Classe é a instância', 'Classe só existe em Java'], correct: 1, explanation: 'A Classe define a estrutura (atributos e métodos). O Objeto é a instância real criada na memória com new. Uma classe pode gerar infinitos objetos independentes.' },
  { id: 'q62e', lessonId: 'm3-whatispoo', question: 'Em POO, um objeto possui:', options: ['Apenas métodos', 'Estado (atributos) e comportamento (métodos)', 'Apenas atributos', 'Apenas um construtor'], correct: 1, explanation: 'Objeto é uma instância de uma classe. Possui estado (valores dos atributos) e comportamento (métodos que pode executar).' },

  // M3 - Classes e Objetos
  { id: 'q65', lessonId: 'm3-classes', question: 'Qual a relação entre Classe e Objeto?', options: ['São a mesma coisa', 'Classe é o molde, Objeto é a instância criada com new', 'Objeto é o molde, Classe é a instância', 'Não há relação'], correct: 1, explanation: 'A Classe é o molde/template que define atributos e métodos. O Objeto é a instância real criada na memória com new.' },
  { id: 'q66', lessonId: 'm3-classes', question: 'O que acontece quando fazemos Carro b = a; (sem new)?', options: ['Cria uma cópia independente do objeto', 'b aponta para o MESMO objeto que a na memória', 'Dá erro de compilação', 'Cria dois objetos iguais'], correct: 1, explanation: 'Sem new, a variável b recebe a referência (endereço) do mesmo objeto. Alterar b.cor também altera a.cor porque ambas apontam para o mesmo local na memória.' },
  { id: 'q67', lessonId: 'm3-classes', question: 'Cada objeto de uma mesma classe tem seus próprios atributos?', options: ['Não, todos compartilham', 'Sim, cada instância tem sua própria cópia dos atributos', 'Só se forem static', 'Só em C++'], correct: 1, explanation: 'Atributos de instância (não static) são próprios de cada objeto. Alterar meuCarro.cor não afeta outroCarro.cor.' },
  { id: 'q67b', lessonId: 'm3-classes', question: 'Quantas classes public podem existir em um único arquivo .java?', options: ['Quantas quiser', 'No máximo uma', 'Exatamente duas', 'Nenhuma'], correct: 1, explanation: 'Cada arquivo .java pode ter apenas UMA classe public, e o nome do arquivo deve ser igual ao nome dessa classe.' },
  { id: 'q67c', lessonId: 'm3-classes', question: 'Para modelar classes a partir de um enunciado, substantivos viram ___ e verbos viram ___.', options: ['métodos / atributos', 'classes ou atributos / métodos', 'variáveis / funções', 'imports / exports'], correct: 1, explanation: 'Substantivos do problema (Aluno, nota, nome) viram classes ou atributos. Verbos (calcular, exibir, emprestar) viram métodos.' },
  { id: 'q67e', lessonId: 'm3-classes', question: 'O operador new em Java serve para:', options: ['Declarar uma variável', 'Criar uma nova instância (objeto) de uma classe na memória', 'Importar uma classe', 'Definir um construtor'], correct: 1, explanation: 'new aloca memória para um novo objeto e chama o construtor para inicializá-lo.' },

  // M3 - Atributos e Métodos
  { id: 'q68', lessonId: 'm3-attributes', question: 'Qual o valor padrão de um atributo do tipo String ao criar um objeto com new?', options: ['""  (string vazia)', 'null', '0', 'undefined'], correct: 1, explanation: 'Atributos de tipo String (e qualquer objeto) são inicializados como null. Tipos primitivos numéricos (int, double) começam com 0, e boolean com false.' },
  { id: 'q69', lessonId: 'm3-attributes', question: 'Métodos que alteram o estado devem:', options: ['Sempre ser public', 'Validar parâmetros e condições antes de alterar', 'Ser static', 'Retornar void obrigatoriamente'], correct: 1, explanation: 'Boa prática: sempre validar (ex.: qtd > 0 && qtd <= estoque) antes de modificar atributos, para evitar estados inválidos.' },
  { id: 'q69b', lessonId: 'm3-attributes', question: 'Qual a diferença entre um método void e um método com retorno?', options: ['Não há diferença', 'void não retorna valor; métodos com retorno devolvem um resultado ao chamador', 'void é mais rápido', 'Métodos com retorno não podem ter parâmetros'], correct: 1, explanation: 'void indica que o método executa ações mas não devolve resultado. Métodos com retorno (int, double, boolean, String) devolvem um valor que o chamador pode guardar em uma variável.' },
  { id: 'q69f', lessonId: 'm3-attributes', question: 'O que acontece se você não guardar o retorno de um método em uma variável?', options: ['Dá erro de compilação', 'O resultado é perdido/ignorado', 'O valor é salvo automaticamente', 'O programa trava'], correct: 1, explanation: 'Se você chama calc.somar(10, 20) sem guardar em uma variável, o resultado 30 é calculado mas descartado. Precisa fazer: double r = calc.somar(10, 20);' },
  { id: 'q69h', lessonId: 'm3-attributes', question: 'Atributos de instância são declarados:', options: ['Dentro de um método', 'Dentro da classe, fora de qualquer método', 'No main()', 'No construtor apenas'], correct: 1, explanation: 'Atributos (variáveis de instância) são declarados no corpo da classe, fora de métodos. Cada objeto tem sua cópia.' },
  { id: 'q69i', lessonId: 'm3-attributes', question: 'Um método que retorna boolean geralmente começa com:', options: ['get', 'is ou has', 'set', 'check'], correct: 1, explanation: 'Convenção Java: métodos boolean usam prefixos is (isAtivo) ou has (hasPermissao). get é para outros tipos.' },

  // M3 - Construtores
  { id: 'q69c', lessonId: 'm3-constructors', question: 'Quando o construtor é chamado?', options: ['Ao declarar a classe', 'Automaticamente no momento do new', 'No final do programa', 'Quando chamamos super()'], correct: 1, explanation: 'O construtor roda automaticamente quando você executa new NomeClasse(...). Ele inicializa o objeto com os valores passados.' },
  { id: 'q69d', lessonId: 'm3-constructors', question: 'O que acontece se definir um construtor com parâmetros mas não definir um construtor vazio?', options: ['Nada muda', 'new Classe() sem argumentos dá erro de compilação', 'O Java cria um construtor vazio automaticamente', 'O programa compila mas trava em runtime'], correct: 1, explanation: 'Ao definir qualquer construtor com parâmetros, o construtor padrão (sem parâmetros) desaparece. Para usar new Classe(), precisa definir o construtor vazio explicitamente.' },
  { id: 'q69e', lessonId: 'm3-constructors', question: 'Para que serve this() dentro de um construtor?', options: ['Criar novo objeto', 'Chamar outro construtor da MESMA classe', 'Chamar o construtor da classe pai', 'Retornar o objeto atual'], correct: 1, explanation: 'this() chama outro construtor da mesma classe, permitindo reutilizar lógica sem duplicar código. Deve ser a primeira linha do construtor.' },
  { id: 'q69g', lessonId: 'm3-constructors', question: 'O que acontece se escrever "nome = nome" (sem this) no construtor?', options: ['Funciona normalmente', 'O parâmetro é atribuído a si mesmo e o atributo da classe fica null', 'Dá erro de compilação', 'O programa trava'], correct: 1, explanation: 'Sem this, "nome" se refere ao parâmetro nos dois lados. O parâmetro é atribuído a ele mesmo e o atributo da classe continua com o valor padrão (null para String, 0 para int).' },
  { id: 'q69j', lessonId: 'm3-constructors', question: 'Um construtor tem o mesmo nome que:', options: ['O pacote', 'A classe', 'O método main', 'O arquivo'], correct: 1, explanation: 'O construtor DEVE ter exatamente o mesmo nome da classe e NÃO tem tipo de retorno (nem void).' },
  { id: 'q69k', lessonId: 'm3-constructors', question: 'Quantos construtores uma classe pode ter?', options: ['Apenas 1', 'Quantos quiser, desde que tenham parâmetros diferentes', 'No máximo 3', 'Apenas 2'], correct: 1, explanation: 'Uma classe pode ter múltiplos construtores (sobrecarga). Cada um deve ter lista de parâmetros diferente.' },

  // M3 - Static
  { id: 'q73', lessonId: 'm3-static', question: 'Membros static pertencem a:', options: ['Cada objeto', 'À classe (compartilhados por todos)', 'Só ao main', 'Nenhum'], correct: 1, explanation: 'static = da classe, compartilhado por todas as instâncias.' },
  { id: 'q74', lessonId: 'm3-static', question: 'Um método static pode acessar um atributo de instância (não static)?', options: ['Sim, sempre', 'Não, não existe this em contexto static', 'Só se for public', 'Só em C++'], correct: 1, explanation: 'Em método static não há referência a um objeto (this); logo não dá para acessar atributos de instância.' },
  { id: 'q75', lessonId: 'm3-static', question: 'Como chamar um método static?', options: ['objeto.metodo()', 'NomeClasse.metodo()', 'super.metodo()', 'this.metodo()'], correct: 1, explanation: 'Métodos static são chamados pela classe: Funcionario.getTotal().' },
  { id: 'q75b', lessonId: 'm3-static', question: 'Um contador de objetos criados deve ser:', options: ['Atributo de instância', 'Atributo static (pertence à classe)', 'Variável local', 'Constante final'], correct: 1, explanation: 'Um contador compartilhado por todos os objetos deve ser static. Cada new incrementa o mesmo contador.' },
  { id: 'q75c', lessonId: 'm3-static', question: 'Métodos utilitários como Math.sqrt() são static porque:', options: ['São mais rápidos', 'Não dependem de estado de instância; operam só nos parâmetros', 'É obrigatório no Math', 'São privados'], correct: 1, explanation: 'Métodos que não dependem de atributos de instância devem ser static. Podem ser chamados sem criar objeto.' },
  { id: 'q75d', lessonId: 'm3-static', question: 'Uma constante de classe (ex: PI) geralmente é declarada como:', options: ['private int', 'public static final', 'protected static', 'private final'], correct: 1, explanation: 'static final = constante de classe. public permite acesso externo. Convenção: UPPER_SNAKE_CASE. Ex: public static final double PI = 3.14159.' },

  // M3 - this
  { id: 'q76', lessonId: 'm3-this', question: 'O que é this dentro de um método de instância?', options: ['A classe', 'Referência ao objeto atual que está executando o método', 'O método pai', 'O pacote'], correct: 1, explanation: 'this é a referência ao próprio objeto que recebeu a chamada do método.' },
  { id: 'q77', lessonId: 'm3-this', question: 'Para que serve retornar this em um setter?', options: ['Para compilar', 'Para permitir method chaining (encadear chamadas)', 'Para criar cópia', 'Nada'], correct: 1, explanation: 'return this permite objeto.setA(1).setB(2).' },
  { id: 'q78', lessonId: 'm3-this', question: 'Podemos usar this em um método static?', options: ['Sim', 'Não, não existe objeto atual em static', 'Só no main', 'Só em interface'], correct: 1, explanation: 'Em static não há "objeto atual"; this não existe.' },
  { id: 'q78b', lessonId: 'm3-this', question: 'Quando this.nome é necessário no construtor?', options: ['Sempre', 'Quando o parâmetro tem o mesmo nome que o atributo', 'Nunca', 'Só com String'], correct: 1, explanation: 'this.nome diferencia o atributo da classe do parâmetro com mesmo nome. Sem this, o parâmetro "esconde" (shadow) o atributo.' },
  { id: 'q78c', lessonId: 'm3-this', question: 'this pode ser passado como argumento para outro método?', options: ['Não', 'Sim, passa a referência do objeto atual', 'Só em construtores', 'Só em static'], correct: 1, explanation: 'this é uma referência ao objeto atual e pode ser passado como argumento. Ex: outraClasse.registrar(this).' },
  { id: 'q78d', lessonId: 'm3-this', question: 'O que é method chaining (encadeamento)?', options: ['Chamar vários métodos seguidos com ponto', 'Retornar this para permitir obj.setA(1).setB(2)', 'Herança de métodos', 'Usar this() no construtor'], correct: 1, explanation: 'Quando um setter retorna this, permite encadear: pessoa.setNome("Ana").setIdade(25). Cada método retorna o próprio objeto.' },

  // M3 - Inheritance (already has q80, q81)

  // M3 - Encapsulation
  { id: 'q70', lessonId: 'm3-encapsulation', question: 'Por que usar private nos atributos?', options: ['Para o código compilar mais rápido', 'Para proteger dados de alterações inválidas', 'Porque é obrigatório em Java', 'Para economizar memória'], correct: 1, explanation: 'private impede acesso direto. O atributo só pode ser lido/alterado por métodos da própria classe, que fazem validação.' },
  { id: 'q71', lessonId: 'm3-encapsulation', question: 'Todo atributo private precisa de getter E setter?', options: ['Sim, sempre', 'Não, depende se o atributo precisa ser lido ou alterado de fora', 'Sim, é obrigatório', 'Não, nunca use setters'], correct: 1, explanation: 'Crie getters/setters apenas quando necessário. CPF pode ter só getter (somente leitura). Saldo é melhor controlado por depositar/sacar. Dados internos podem não ter nenhum dos dois.' },
  { id: 'q72', lessonId: 'm3-encapsulation', question: 'O que é "encapsulamento falso"?', options: ['Usar private sem getters', 'Criar setters que apenas fazem this.x = x sem validação', 'Não usar construtores', 'Usar public em todos os atributos'], correct: 1, explanation: 'Encapsulamento falso é ter atributos private mas setters sem validação (tipo setSaldo(s) { this.saldo = s; }). Aceita qualquer valor — mesma coisa que public, com mais código.' },
  { id: 'q72b', lessonId: 'm3-encapsulation', question: 'Qual a convenção para getter de atributos boolean?', options: ['getAtivo()', 'isAtivo()', 'hasAtivo()', 'checkAtivo()'], correct: 1, explanation: 'Para atributos boolean, a convenção Java é usar "is" em vez de "get": isAtivo(), isVazio(), isPago(). Para outros tipos, usa-se getXxx().' },
  { id: 'q72c', lessonId: 'm3-encapsulation', question: 'Qual a ordem de visibilidade, do mais restrito ao mais aberto?', options: ['public > protected > default > private', 'private > default > protected > public', 'private > protected > default > public', 'default > private > protected > public'], correct: 1, explanation: 'private (só a classe) → default/package (mesmo pacote) → protected (pacote + subclasses) → public (todos).' },
  { id: 'q72d', lessonId: 'm3-encapsulation', question: 'Getter e setter devem ser criados para TODOS os atributos?', options: ['Sim, sempre', 'Não, apenas quando há necessidade real de acesso externo', 'Sim, é obrigatório', 'Só para String'], correct: 1, explanation: 'Crie getter/setter apenas quando necessário. Atributos internos podem não precisar de nenhum dos dois. Saldo é melhor controlado por depositar()/sacar().' },

  // M3 - Inheritance
  { id: 'q80', lessonId: 'm3-inheritance', question: 'Qual palavra-chave indica herança?', options: ['implements', 'extends', 'inherits', 'super'], correct: 1, explanation: 'extends indica que uma classe herda de outra. implements é para interfaces.' },
  { id: 'q81', lessonId: 'm3-inheritance', question: 'Quando NÃO usar herança?', options: ['Quando a relação é "é um"', 'Quando a relação é "tem um"', 'Quando quer reaproveitar código sempre', 'Nunca, sempre use'], correct: 1, explanation: 'Se a relação é "tem um" (Carro TEM Motor), use composição. Herança é para "é um" (Cachorro É Animal).' },
  { id: 'q82', lessonId: 'm3-inheritance', question: 'No construtor da subclasse, a primeira linha deve ser:', options: ['this()', 'super() ou super(args)', 'return', 'new Pai()'], correct: 1, explanation: 'A primeira linha do construtor da subclasse deve chamar super(...) para inicializar a parte herdada.' },
  { id: 'q82b', lessonId: 'm3-inheritance', question: 'Java suporta herança múltipla de classes?', options: ['Sim', 'Não, apenas herança simples (uma superclasse)', 'Sim, desde Java 8', 'Só com abstract'], correct: 1, explanation: 'Java permite extends de apenas UMA classe. Para "herança múltipla" de comportamento, use interfaces (implements).' },
  { id: 'q82c', lessonId: 'm3-inheritance', question: 'Para que serve super.metodo() na subclasse?', options: ['Criar novo método', 'Chamar a versão do método da superclasse', 'Tornar o método static', 'Ocultar o método'], correct: 1, explanation: 'super.metodo() chama a implementação da superclasse. Útil quando a subclasse sobrescreve o método mas quer reutilizar a lógica do pai.' },
  { id: 'q82d', lessonId: 'm3-inheritance', question: 'Atributos private da superclasse são herdados pela subclasse?', options: ['Sim, e são acessíveis diretamente', 'Existem no objeto mas NÃO são acessíveis diretamente (precisa getter)', 'Não são herdados', 'Só se forem static'], correct: 1, explanation: 'Atributos private existem no objeto da subclasse (são herdados), mas só podem ser acessados via métodos public/protected da superclasse.' },

  // M3 - Polymorphism
  { id: 'q85', lessonId: 'm3-polymorphism', question: 'O que é polimorfismo?', options: ['Muitas classes', 'Um método com comportamentos diferentes dependendo do objeto', 'Herança múltipla', 'Criar muitos objetos'], correct: 1, explanation: 'Polimorfismo = "muitas formas". O mesmo método se comporta diferentemente em cada subclasse.' },
  { id: 'q86', lessonId: 'm3-polymorphism', question: 'Para que serve @Override?', options: ['Criar um método novo', 'Indicar sobrescrita de método do pai', 'Tornar o método static', 'Ocultar o método do pai'], correct: 1, explanation: '@Override indica que o método está sobrescrevendo um método da superclasse. Ajuda a evitar erros de digitação.' },
  { id: 'q87', lessonId: 'm3-polymorphism', question: 'Animal a = new Cachorro(); a.emitirSom(); qual método roda?', options: ['O de Animal', 'O de Cachorro (objeto real)', 'Nenhum', 'Dá erro'], correct: 1, explanation: 'O Java escolhe o método pelo tipo do objeto em tempo de execução (polimorfismo).' },
  { id: 'q87b', lessonId: 'm3-polymorphism', question: 'List<Animal> animais pode receber um Cachorro?', options: ['Não, tipos diferentes', 'Sim, Cachorro é um Animal (polimorfismo)', 'Só com cast', 'Dá ClassCastException'], correct: 1, explanation: 'Se Cachorro extends Animal, um Cachorro É um Animal. Pode ser adicionado à lista de Animal. Isso é polimorfismo.' },
  { id: 'q87c', lessonId: 'm3-polymorphism', question: 'O que é necessário para sobrescrever um método?', options: ['Mesmo nome apenas', 'Mesma assinatura (nome + parâmetros) na subclasse', 'Parâmetros diferentes', 'Usar static'], correct: 1, explanation: 'Sobrescrita (override) exige mesma assinatura: mesmo nome, mesmos parâmetros, tipo de retorno compatível. @Override é boa prática.' },
  { id: 'q87d', lessonId: 'm3-polymorphism', question: 'Binding dinâmico (late binding) em Java ocorre com:', options: ['Atributos', 'Métodos de instância sobrescritos', 'Métodos static', 'Construtores'], correct: 1, explanation: 'A JVM decide qual método de instância chamar em tempo de execução, baseado no tipo real do objeto (não o tipo da referência).' },

  // M3 - Abstraction
  { id: 'q88', lessonId: 'm3-abstraction', question: 'Uma classe abstrata (abstract class) pode ser instanciada com new?', options: ['Sim', 'Não', 'Só no main', 'Só se tiver um método'], correct: 1, explanation: 'Classe abstrata não pode ser instanciada; só suas subclasses concretas.' },
  { id: 'q89', lessonId: 'm3-abstraction', question: 'Método abstract deve ter corpo (implementação)?', options: ['Sim', 'Não, só assinatura; a subclasse implementa', 'Opcional', 'Só em interface'], correct: 1, explanation: 'Método abstract não tem corpo; cada subclasse concreta implementa.' },
  { id: 'q89b', lessonId: 'm3-abstraction', question: 'Uma classe abstrata pode ter métodos concretos (com corpo)?', options: ['Não', 'Sim', 'Só um', 'Só static'], correct: 1, explanation: 'Pode misturar métodos abstract e métodos concretos na mesma classe abstrata.' },
  { id: 'q89c', lessonId: 'm3-abstraction', question: 'Subclasse que NÃO implementa todos os métodos abstratos herdados:', options: ['Compila normalmente', 'Também deve ser declarada como abstract', 'Dá erro de execução', 'Os métodos ficam vazios'], correct: 1, explanation: 'Se a subclasse não implementa todos os métodos abstratos, ela mesma deve ser abstract. Só classes concretas implementam tudo.' },
  { id: 'q89d', lessonId: 'm3-abstraction', question: 'Quando usar classe abstrata vs interface?', options: ['São iguais', 'Abstrata: compartilhar código/estado; Interface: contratos puros', 'Interface é sempre melhor', 'Abstrata é sempre melhor'], correct: 1, explanation: 'Classe abstrata: compartilhar código e estado entre classes relacionadas. Interface: definir contrato para classes não relacionadas.' },
  { id: 'q89e', lessonId: 'm3-abstraction', question: 'Podemos ter referências de tipo abstrato? Ex: Forma f = new Circulo()', options: ['Não', 'Sim, o objeto real é da subclasse concreta', 'Só em arrays', 'Só como parâmetro'], correct: 1, explanation: 'Podemos declarar variáveis do tipo abstrato, mas o objeto real deve ser de uma subclasse concreta. Isso é polimorfismo.' },

  // M3 - Interfaces
  { id: 'q90', lessonId: 'm3-interfaces', question: 'Uma classe pode implementar múltiplas interfaces?', options: ['Não', 'Sim', 'Apenas 2', 'Apenas com abstract'], correct: 1, explanation: 'Java permite implementar MÚLTIPLAS interfaces, mas só pode estender UMA classe.' },
  { id: 'q91', lessonId: 'm3-interfaces', question: 'Quem implementa uma interface deve:', options: ['Só estender outra classe', 'Implementar todos os métodos declarados na interface', 'Usar abstract em todos', 'Não usar new'], correct: 1, explanation: 'A classe que implements deve fornecer implementação para todos os métodos da interface.' },
  { id: 'q92', lessonId: 'm3-interfaces', question: 'Interface em Java define principalmente:', options: ['Implementação', 'Contrato (quais métodos existirão)', 'Atributos privados', 'Construtores'], correct: 1, explanation: 'Interface define o contrato: assinaturas dos métodos que as implementações devem ter.' },
  { id: 'q92b', lessonId: 'm3-interfaces', question: 'Métodos em interfaces são, por padrão:', options: ['private', 'public abstract', 'protected', 'static'], correct: 1, explanation: 'Métodos declarados em interfaces são implicitamente public e abstract. A partir do Java 8, podem ter default e static.' },
  { id: 'q92c', lessonId: 'm3-interfaces', question: 'Uma interface pode ter atributos?', options: ['Sim, qualquer tipo', 'Apenas constantes (public static final)', 'Não, nunca', 'Só private'], correct: 1, explanation: 'Variáveis em interfaces são implicitamente public static final (constantes). Não podem ter atributos de instância.' },
  { id: 'q92d', lessonId: 'm3-interfaces', question: 'Vantagem de programar para a interface (List) e não para a implementação (ArrayList)?', options: ['É mais rápido', 'Permite trocar a implementação sem mudar o código que usa', 'É obrigatório', 'Não tem vantagem'], correct: 1, explanation: 'Usar List em vez de ArrayList permite trocar para LinkedList sem alterar o código consumidor. Depender de abstrações.' },

  // M3 - Composition
  { id: 'q93', lessonId: 'm3-composition', question: '"Carro tem um Motor" deve ser modelado com:', options: ['Herança (Carro extends Motor)', 'Composição (atributo Motor no Carro)', 'Interface', 'Classe abstrata'], correct: 1, explanation: '"Tem um" = composição (atributo). "É um" = herança.' },
  { id: 'q94', lessonId: 'm3-composition', question: 'Composição costuma ser mais flexível que herança porque:', options: ['É mais rápida', 'Permite trocar componentes e não cria acoplamento forte com a superclasse', 'Obriga a usar abstract', 'Não usa new'], correct: 1, explanation: 'Você pode trocar o componente (ex.: outro Motor) sem mudar a hierarquia de classes.' },
  { id: 'q95a', lessonId: 'm3-composition', question: 'Prefira composição a herança quando a relação for:', options: ['"é um"', '"tem um"', '"implementa"', '"estende"'], correct: 1, explanation: '"Tem um" → composição. "É um" → herança.' },
  { id: 'q95a2', lessonId: 'm3-composition', question: 'Na composição, se o objeto "dono" for destruído, os componentes:', options: ['Continuam existindo', 'Também são destruídos (ciclo de vida acoplado)', 'Se tornam null', 'Dão erro'], correct: 1, explanation: 'Na composição forte, os componentes existem apenas como parte do dono. Ex: Pedido destruído → seus Itens também deixam de existir.' },
  { id: 'q95a3', lessonId: 'm3-composition', question: 'Uma classe pode usar herança E composição ao mesmo tempo?', options: ['Não', 'Sim, são complementares', 'Só em Java 11+', 'Só com interfaces'], correct: 1, explanation: 'É comum combinar: uma classe pode estender outra (herança) e ter atributos de outras classes (composição).' },

  // M3 - Overloading
  { id: 'q95b', lessonId: 'm3-overloading', question: 'Sobrecarga (overloading) é:', options: ['Mesmo nome, parâmetros diferentes, mesma classe', 'Mesmo nome na classe filha', 'Só para construtores', 'Herança'], correct: 0, explanation: 'Sobrecarga = vários métodos mesmo nome, parâmetros diferentes, na mesma classe.' },
  { id: 'q95c', lessonId: 'm3-overloading', question: 'Sobrescrita (overriding) é decidida em:', options: ['Compilação', 'Execução (polimorfismo)', 'Load da classe', 'Nunca'], correct: 1, explanation: 'A JVM escolhe qual método chamar em tempo de execução pelo tipo real do objeto.' },
  { id: 'q95d', lessonId: 'm3-overloading', question: 'Posso sobrecarregar mudando só o tipo de retorno?', options: ['Sim', 'Não, a lista de parâmetros deve ser diferente', 'Só com @Override', 'Só em interface'], correct: 1, explanation: 'Sobrecarga exige parâmetros diferentes; retorno sozinho não diferencia.' },
  { id: 'q95d2', lessonId: 'm3-overloading', question: 'Sobrecarga de construtores segue a mesma regra?', options: ['Não', 'Sim: mesmo nome (da classe), parâmetros diferentes', 'Construtores não podem ser sobrecarregados', 'Só com this()'], correct: 1, explanation: 'Construtores também podem ser sobrecarregados: mesmo nome (da classe), com listas de parâmetros diferentes.' },
  { id: 'q95d3', lessonId: 'm3-overloading', question: 'System.out.println() aceita int, double, String... Isso é exemplo de:', options: ['Herança', 'Sobrecarga (overloading)', 'Polimorfismo de execução', 'Interface'], correct: 1, explanation: 'println() tem várias versões sobrecarregadas: println(int), println(double), println(String), println(Object), etc.' },
  { id: 'q95d4', lessonId: 'm3-overloading', question: '@Override na sobrescrita serve para:', options: ['Tornar o método mais rápido', 'O compilador verificar se a assinatura corresponde à da superclasse', 'Criar um novo método', 'Chamar super'], correct: 1, explanation: '@Override faz o compilador validar que você está sobrescrevendo um método existente. Se errar a assinatura, dá erro de compilação.' },

  // M3 - Access
  { id: 'q95e', lessonId: 'm3-access', question: 'private é acessível em:', options: ['Qualquer lugar', 'Apenas dentro da própria classe', 'No pacote', 'Nas subclasses'], correct: 1, explanation: 'private = só dentro da mesma classe.' },
  { id: 'q95f', lessonId: 'm3-access', question: 'protected permite acesso em:', options: ['Só na classe', 'Mesmo pacote ou subclasses', 'Só em subclasses', 'Em qualquer arquivo'], correct: 1, explanation: 'protected = mesma classe, mesmo pacote e subclasses (mesmo em outro pacote).' },
  { id: 'q95g', lessonId: 'm3-access', question: 'Modificador default (nenhum) permite acesso em:', options: ['Qualquer lugar', 'Apenas no mesmo pacote', 'Só na classe', 'Só em subclasses'], correct: 1, explanation: 'Sem modificador = visibilidade de pacote (package-private).' },
  { id: 'q95g2', lessonId: 'm3-access', question: 'Uma classe public pode ser acessada de:', options: ['Só do mesmo pacote', 'Qualquer pacote (com import)', 'Só de subclasses', 'Só do mesmo arquivo'], correct: 1, explanation: 'public class é visível em qualquer pacote. Basta importar com import para usar.' },
  { id: 'q95g3', lessonId: 'm3-access', question: 'Qual modificador usar para um método auxiliar interno da classe?', options: ['public', 'private', 'protected', 'default'], correct: 1, explanation: 'private é ideal para métodos internos (helpers) que são detalhe de implementação e não devem ser chamados de fora.' },
  { id: 'q95g4', lessonId: 'm3-access', question: 'Classe sem modificador (default) é acessível em:', options: ['Qualquer lugar', 'Apenas no mesmo pacote', 'Apenas na mesma classe', 'Apenas em subclasses'], correct: 1, explanation: 'Sem modificador = package-private. A classe só é visível dentro do mesmo pacote.' },

  // M3 - Exceptions
  { id: 'q95', lessonId: 'm3-exceptions', question: 'O bloco finally sempre executa?', options: ['Não, só quando há erro', 'Sim, com ou sem exceção', 'Apenas se não houver catch', 'Apenas com exceções checked'], correct: 1, explanation: 'finally sempre executa, independentemente de ter ocorrido exceção ou não. Útil para cleanup.' },
  { id: 'q96', lessonId: 'm3-exceptions', question: 'Exceções checked (ex.: IOException) devem ser:', options: ['Ignoradas', 'Tratadas com try/catch ou declaradas com throws', 'Só em main', 'Convertidas em unchecked'], correct: 1, explanation: 'Checked exceptions obrigam tratamento ou declaração throws.' },
  { id: 'q97', lessonId: 'm3-exceptions', question: 'NullPointerException é checked ou unchecked?', options: ['Checked', 'Unchecked (RuntimeException)', 'Ambos', 'Nenhum'], correct: 1, explanation: 'RuntimeException e subclasses são unchecked; não obrigam try/catch.' },
  { id: 'q97b', lessonId: 'm3-exceptions', question: 'O que acontece se uma exceção não for tratada?', options: ['É ignorada', 'O programa encerra com stack trace de erro', 'É tratada automaticamente', 'Vira warning'], correct: 1, explanation: 'Exceções não tratadas propagam até o main. Se não capturadas, encerram o programa com stack trace.' },
  { id: 'q97c', lessonId: 'm3-exceptions', question: 'Posso ter múltiplos catch para um único try?', options: ['Não', 'Sim, cada catch trata um tipo diferente de exceção', 'Só com finally', 'Máximo 2'], correct: 1, explanation: 'Pode ter vários catch, cada um para um tipo de exceção. O mais específico deve vir primeiro.' },
  { id: 'q97d', lessonId: 'm3-exceptions', question: 'throw vs throws — qual a diferença?', options: ['São iguais', 'throw lança a exceção; throws declara que o método pode lançar', 'throws lança; throw declara', 'throw é checked, throws unchecked'], correct: 1, explanation: 'throw new Exception("msg") lança a exceção. throws na assinatura avisa que o método pode lançar esse tipo.' },

  // M3 - SOLID
  { id: 'q98', lessonId: 'm3-solid', question: 'SRP (Single Responsibility) significa:', options: ['Uma classe faz tudo', 'Uma classe deve ter apenas uma razão para mudar', 'Só um método por classe', 'Só um atributo'], correct: 1, explanation: 'Cada classe com uma responsabilidade bem definida.' },
  { id: 'q99', lessonId: 'm3-solid', question: 'Open/Closed prega:', options: ['Abrir e fechar arquivos', 'Aberta para extensão, fechada para modificação', 'Só uma subclasse', 'Código fechado'], correct: 1, explanation: 'Estender com novas classes sem modificar o código existente.' },
  { id: 'q100', lessonId: 'm3-solid', question: 'Dependency Inversion: devemos depender de:', options: ['Classes concretas só', 'Abstrações (interfaces/classes abstratas)', 'Só de static', 'Do main'], correct: 1, explanation: 'Depender de abstrações permite trocar implementações sem quebrar o código.' },
  { id: 'q100b', lessonId: 'm3-solid', question: 'O "L" de SOLID (Liskov) significa:', options: ['Limitação de classes', 'Subclasses devem substituir superclasses sem quebrar o comportamento', 'Loops devem ser limitados', 'Listas devem usar generics'], correct: 1, explanation: 'Princípio de Substituição de Liskov: onde se usa a superclasse, deve ser possível usar qualquer subclasse sem comportamento inesperado.' },
  { id: 'q100c', lessonId: 'm3-solid', question: 'Interface Segregation prega:', options: ['Uma interface gigante', 'Interfaces pequenas e específicas em vez de uma grande', 'Segregar classes', 'Não usar interfaces'], correct: 1, explanation: 'Muitas interfaces específicas são melhores que uma "faz-tudo". Clientes não devem depender de métodos que não usam.' },
  { id: 'q100d', lessonId: 'm3-solid', question: 'SRP evita classes que:', options: ['Têm poucos métodos', 'Fazem muitas coisas diferentes (God Class)', 'Usam herança', 'São abstratas'], correct: 1, explanation: 'Classes com muitas responsabilidades (God Class) são difíceis de manter. SRP: uma classe = uma responsabilidade.' },

  // M3 - Project
  { id: 'q101', lessonId: 'm3-project', question: 'No projeto final, Exibivel é:', options: ['Classe abstrata', 'Interface (contrato)', 'Classe concreta', 'Método'], correct: 1, explanation: 'Interface que define o contrato exibir().' },
  { id: 'q102', lessonId: 'm3-project', question: 'ItemCadastro é classe abstrata porque:', options: ['Não tem métodos', 'Tem método abstrato (ex.: calcularValor) e não deve ser instanciada diretamente', 'É interface', 'É final'], correct: 1, explanation: 'Define comportamento base e obriga subclasses a implementar calcularValor().' },
  { id: 'q103', lessonId: 'm3-project', question: 'Produto estende ItemCadastro e implementa Exibivel. Isso usa:', options: ['Só herança', 'Herança e interface (reuso + contrato)', 'Só interface', 'Nada'], correct: 1, explanation: 'extends para herdar ItemCadastro; implements para o contrato Exibivel.' },
  { id: 'q103b', lessonId: 'm3-project', question: 'Por que usar ArrayList<ItemCadastro> em vez de ArrayList<Produto>?', options: ['É mais rápido', 'Permite armazenar qualquer subclasse de ItemCadastro (polimorfismo)', 'É obrigatório', 'Não faz diferença'], correct: 1, explanation: 'Usando o tipo base, a lista aceita Produto, Servico, ou qualquer futura subclasse. Polimorfismo e extensibilidade.' },
  { id: 'q103c', lessonId: 'm3-project', question: 'Qual padrão o projeto usa para separar responsabilidades?', options: ['Tudo no main', 'Classes com responsabilidades únicas (modelo, serviço, interface)', 'MVC completo', 'Singleton'], correct: 1, explanation: 'O projeto separa: classes de modelo (Produto, Servico), classe de serviço (Cadastro), e classe principal (menu e interação).' },
  { id: 'q103d', lessonId: 'm3-project', question: 'calcularValor() abstract em ItemCadastro garante que:', options: ['Todos tenham o mesmo preço', 'Cada subclasse forneça sua própria lógica de cálculo', 'O método não possa ser chamado', 'Retorne void'], correct: 1, explanation: 'abstract obriga cada subclasse concreta a implementar sua versão. Produto calcula com margem, Servico com taxa, etc.' },
];
